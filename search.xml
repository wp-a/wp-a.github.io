<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MambaOut</title>
      <link href="/2025/09/MambaOut/"/>
      <url>/2025/09/MambaOut/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>MambaOut</h1><p>MambaOut: Do We Really Need Mamba for Vision?  (CVPR 2025)</p><p>论文地址：<a href="https://github.com/yuweihao/MambaOut">https://github.com/yuweihao/MambaOut</a></p><p>代码地址：<a href="https://arxiv.org/pdf/2405.07992">https://arxiv.org/pdf/2405.07992</a></p><p>mamba主要被引入解决注意力机制的二次复杂度问题，与基于卷积和注意力的模型相比，Mamba在视觉方面的表现通常令人失望。本文得出了一个结论就是Mamba非常适合具有长序列和自回归特征的任务，由于图像分类和这两种特征都不符合，所以通过堆叠mamba块，同时移除核心token混合器SSM，得到MambaOut模型在ImageNet图像分类任务上超越了所有视觉Mamba模型。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> MambaOut </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> Mamba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图神经网络</title>
      <link href="/2025/09/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
      <url>/2025/09/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>图神经网络（GNN）全面指：从基础到高级应用</h1><h2 id="引言">引言</h2><p>在数据爆炸的时代，传统深度学习模型如CNN和RNN在处理结构化数据（如图像和序列）上取得了巨大成功，但现实世界中的许多数据都具有<strong>图结构</strong>（Graph Structure），例如社交网络、分子结构、知识图谱、交通网络等。这些数据是非欧几里德的（Non-Euclidean），节点之间存在复杂的拓扑关系，无法直接用网格或序列表示。这就是**图神经网络（Graph Neural Networks, GNN）**登场的原因。</p><p>GNN 通过模拟节点间的消息传递机制，捕捉图的局部和全局结构，实现对图数据的表示学习。它已在推荐系统、药物发现、蛋白质折叠预测等领域大放异彩。本文将从基础概念入手，逐步深入GNN的核心原理、经典模型、实现技巧和实际应用，帮助你全面掌握这一技术。无论你是初学者还是有经验的从业者，这篇指南都能提供实用价值。</p><h2 id="图数据基础">图数据基础</h2><h3 id="图的定义与表示">图的定义与表示</h3><p>图 $ G = (V, E) $ 由节点集 $ V $（Vertices）和边集 $ E $（Edges）组成：</p><ul><li><strong>节点（Nodes）</strong>：实体，如用户、原子。</li><li><strong>边（Edges）</strong>：关系，如友谊、化学键。</li><li><strong>类型</strong>：<ul><li>无向图：边无方向（e.g., 社交网络）。</li><li>有向图：边有方向（e.g., 网页链接）。</li><li>加权图：边有权重 $ w_{uv} $（e.g., 相似度分数）。</li><li>异构图：节点/边有多种类型（e.g., 知识图谱）。</li></ul></li></ul><p>图的常见表示方法：</p><ul><li><strong>邻接矩阵（Adjacency Matrix）</strong> $ A \in \mathbb{R}^{|V| \times |V|} $：$ A_{uv} = 1 $ 如果存在边 $ (u, v) $，否则为0。适合小图，但空间复杂度 $ O(|V|^2) $。</li><li><strong>边列表（Edge List）</strong>：稀疏表示，如 $[ (u_1, v_1), (u_2, v_2), \dots ] $，适合大图。</li><li><strong>度矩阵（Degree Matrix）</strong> $ D $，对角线 $ D_{ii} = \sum_j A_{ij} $（节点i的度）。</li><li><strong>拉普拉斯矩阵（Laplacian Matrix）</strong> $ L = D - A $，用于谱分析：它是半正定的，特征分解 $ L = U \Lambda U^T $，其中 $ U $ 是傅里叶基。</li></ul><h3 id="图任务类型">图任务类型</h3><p>GNN 针对不同粒度的数据设计：</p><ul><li><strong>节点级任务</strong>：节点分类（e.g., 预测论文类别）、节点回归（e.g., 预测节点影响力）。</li><li><strong>边级任务</strong>：链接预测（e.g., 推荐朋友）。</li><li><strong>图级任务</strong>：图分类（e.g., 判断分子是否毒性）、图回归（e.g., 预测分子能量）。</li></ul><p>数据集示例：</p><ul><li><strong>节点分类</strong>：Cora（论文引用网络，2708节点，5429边）。</li><li><strong>图分类</strong>：MUTAG（188个分子图）。</li></ul><h2 id="GNN-核心原理">GNN 核心原理</h2><p>GNN 的本质是**消息传递神经网络（Message Passing Neural Network, MPNN）**框架，由Scarselli等人在2009年提出。它通过多层迭代，让每个节点从邻居聚合信息，逐步捕捉多跳（multi-hop）依赖。</p><h3 id="消息传递机制">消息传递机制</h3><p>假设初始节点特征 $ h_v^{(0)} = x_v $（节点v的输入特征）。 在第 $ k $ 层：</p><ol><li><strong>消息生成（Message Generation）</strong>：对于每条边 $ (u, v) $，生成消息 $ m_{uv}^{(k)} = f(h_u^{(k-1)}, h_v^{(k-1)}, e_{uv}) $，其中 $ f $ 是可学习函数（如MLP），$ e_{uv} $ 是边特征。</li><li><strong>聚合（Aggregation）</strong>：节点v聚合邻居消息 $ \tilde{h}<em>v^{(k)} = \text{AGGREGATE}({ m</em>{uv}^{(k)} : u \in \mathcal{N}(v) }) $。<ul><li>常见AGG：Sum（求和）、Mean（平均）、Max（最大）、Attention（注意力）。</li></ul></li><li><strong>更新（Update）</strong>：$ h_v^{(k)} = \text{UPDATE}(\tilde{h}_v^{(k)}, h_v^{(k-1)}) $，UPDATE 如GRU、MLP + ReLU。</li><li><strong>读出（Readout）</strong>（仅图级任务）：全局池化 $ \hat{y} = \text{READOUT}({ h_v^{(K)} : v \in V }) $，如mean pooling或sum。</li></ol><p>数学上，整个过程可并行化，使用稀疏矩阵运算。关键假设：<strong>同质性（Homophily）</strong>，相连节点相似。</p><h3 id="谱方法-vs-空间方法">谱方法 vs 空间方法</h3><ul><li><strong>谱方法（Spectral GNN）</strong>：基于图信号处理（Graph Signal Processing）。图卷积定义为 $ g_\theta * x = U g_\theta(\Lambda) U^T x $，其中 $ g_\theta(\lambda) $ 是滤波器（e.g., 多项式）。优点：理论基础强；缺点：计算 $ U $ 成本高（O(|V|^3)）。<ul><li>示例：ChebNet（2017），用Chebyshev多项式近似滤波器，K阶多项式只需O(K)参数。</li></ul></li><li><strong>空间方法（Spatial GNN）</strong>：直接在节点邻域操作，更高效、可扩展。主流模型如GCN、GAT均属此类。</li></ul><h2 id="经典GNN模型详解">经典GNN模型详解</h2><h3 id="Graph-Convolutional-Network-GCN">Graph Convolutional Network (GCN)</h3><p>Kipf &amp; Welling (2017) 的开创性工作，将CNN推广到图。</p><ul><li><strong>层公式</strong>：$ H^{(l+1)} = \sigma( \hat{D}^{-1/2} \hat{A} \hat{D}^{-1/2} H^{(l)} W^{(l)} ) $。<ul><li>$ \hat{A} = A + I $（加自环，包含自身信息）。</li><li>$ \hat{D} $ 是 $ \hat{A} $ 的度矩阵。</li><li>解释：$ \hat{D}^{-1/2} \hat{A} \hat{D}^{-1/2} $ 是归一化邻接矩阵，第一阶谱卷积近似（localized filter）。</li></ul></li><li><strong>推导简述</strong>：从谱卷积 $ g_\theta * x = U (g_\theta(\Lambda) \odot (U^T x)) U^T $ 简化为一阶Taylor展开，假设 $ g_\theta(\Lambda) = \sum_{k=0}^K T_k(\tilde{L}) \theta_k $（$ \tilde{L} = 2\lambda_{\max}^{-1} L - I $）。</li><li><strong>优点</strong>：简单、参数共享；<strong>缺点</strong>：假设1-hop邻居同质，深层易过平滑。</li><li><strong>应用</strong>：半监督节点分类，在Cora上准确率达81.5%。</li></ul><h3 id="Graph-Attention-Network-GAT">Graph Attention Network (GAT)</h3><p>Veličković等 (2018) 引入注意力机制，提升表达力。</p><ul><li><strong>注意力计算</strong>：$ \alpha_{vu} = \text{softmax}_u ( \text{LeakyReLU}( \mathbf{a}^T [ \mathbf{W} \mathbf{h}_v | \mathbf{W} \mathbf{h}_u ] ) ) $。<ul><li>$ | $ 是拼接，$ \mathbf{a} $ 是注意力向量。</li><li>动态权重，避免固定均值聚合。</li></ul></li><li><strong>更新</strong>：$ \mathbf{h}<em>v’ = \sigma( \sum</em>{u \in \mathcal{N}(v)} \alpha_{vu} \mathbf{W} \mathbf{h}_u ) $。</li><li><strong>多头注意力</strong>：K个头并行，平均或拼接输出，提升稳定性（类似Transformer）。</li><li><strong>优点</strong>：解释性强（可视化注意力权重）；<strong>缺点</strong>：O(|E| d^2)复杂度（d为特征维）。</li><li><strong>变体</strong>：GATv2 (2021)，修复静态注意力问题。</li></ul><h3 id="GraphSAGE">GraphSAGE</h3><p>Hamilton等 (2017) 针对大图设计，支持归纳学习。</p><ul><li><strong>采样聚合</strong>：随机采样固定大小的k-hop邻居，避免全图计算。</li><li><strong>聚合函数</strong>：<ul><li>Mean：$ \text{AGG} = \text{mean}({ \mathbf{h}_u : u \in \text{sample}(\mathcal{N}(v)) }) $。</li><li>Pool：每个邻居用MLP池化后sum。</li><li>LSTM：顺序处理邻居消息。</li></ul></li><li><strong>更新</strong>：$ \mathbf{h}_v^{(k)} = \sigma( \mathbf{W}^{(k)} \cdot \text{CONCAT}( \mathbf{h}_v^{(k-1)}, \text{AGG} ) ) $。</li><li><strong>优点</strong>：可扩展到百万节点图；<strong>缺点</strong>：采样引入方差。</li><li><strong>应用</strong>：Pinterest的引脚推荐。</li></ul><h3 id="Graph-Isomorphism-Network-GIN">Graph Isomorphism Network (GIN)</h3><p>Xu等 (2019) 提升图级表示的区分力。</p><ul><li><strong>公式</strong>：$ \mathbf{h}_v^{(k)} = \text{MLP}^{(k)} ( (1 + \epsilon^{(k)}) \mathbf{h}<em>v^{(k-1)} + \sum</em>{u \in \mathcal{N}(v)} \mathbf{h}_u^{(k-1)} ) $。<ul><li>$ \epsilon^{(k)} $ 可学习，控制自环权重。</li><li>读出：$ \mathbf{h}_G = \text{MLP}( \sum_v \mathbf{h}_v^{(K)} ) $。</li></ul></li><li><strong>理论</strong>：等价于Weisfeiler-Lehman (WL) 图同构测试，能区分更多非同构图。</li><li><strong>优点</strong>：SOTA于图分类基准（如OGB）。</li></ul><h2 id="实现与实践">实现与实践</h2><h3 id="框架选择">框架选择</h3><ul><li><strong>PyTorch Geometric (PyG)</strong>：基于PyTorch，易用。安装：pip install torch-geometric。</li><li><strong>Deep Graph Library (DGL)</strong>：支持PyTorch/TensorFlow/MXNet，适合异构图。</li><li><strong>Spektral</strong>：Keras接口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> GNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> GNN </tag>
            
            <tag> 图神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕 Vision Transformer</title>
      <link href="/2025/06/%E6%89%8B%E6%92%95%20Vision%20Transformer/"/>
      <url>/2025/06/%E6%89%8B%E6%92%95%20Vision%20Transformer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="手撕-Vision-Transformer">手撕 Vision Transformer</h2><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250601121856303.png" style="zoom:50%;" /><p>​之前接触过挺多pytorch框架写的代码的，但是一直没有学过，觉得没啥可学的，上个月看了b站上的一个博主的速成课，感觉确实没啥学的，就是几个函数而已，不过通一下也是很有收获的。我现在准备练习一下代码能力，所以尝试手写一下Vit代码。这也是第一次写除了算法题之外的代码，之前复试结束后联系了一个老师问我写过代码吗，我说没有，也是很尴尬了，最后老师也没要我，嫌我基础太差了，希望能在开学之前把代码能力练好，并且把基础的一些东西弄明白。</p><p>​根据Gemini给我生成了个提示，手写了一遍，不过中间有好几处错误，目前已经更正，不是很熟练，还需要再练习一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 图像分块与嵌入 (Patch Embedding)</span></span><br><span class="line"><span class="comment"># 模块： PatchEmbedding(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PatchEmbedding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_channels,patch_size,embed_dim,image_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.patch_num=(image_size//patch_size)**<span class="number">2</span></span><br><span class="line">        <span class="variable language_">self</span>.emb=nn.Conv2d(in_channels,embed_dim,kernel_size=patch_size,stride=patch_size)</span><br><span class="line">        <span class="variable language_">self</span>.pos_emb=nn.Parameter(torch.randn(<span class="number">1</span>,<span class="variable language_">self</span>.patch_num+<span class="number">1</span>,embed_dim))</span><br><span class="line">        <span class="variable language_">self</span>.cls_emb=nn.Parameter(torch.randn(<span class="number">1</span>,<span class="number">1</span>,embed_dim))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=<span class="variable language_">self</span>.emb(x)</span><br><span class="line">        b,d,h,w=x.shape</span><br><span class="line">        x=x.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>).reshape(b,h*w,d)</span><br><span class="line">        cls_emb=<span class="variable language_">self</span>.cls_emb.expand(b,-<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">        x=torch.cat((cls_emb,x),dim=<span class="number">1</span>)</span><br><span class="line">        out=x+<span class="variable language_">self</span>.pos_emb[:,:<span class="number">1</span>+h*w]</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 多头自注意力机制 (Multi-Head Self-Attention, MSA)</span></span><br><span class="line"><span class="comment"># 模块： MultiHeadSelfAttention(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadSelfAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,embed_dim,num_heads,dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.embed_dim=embed_dim</span><br><span class="line">        <span class="variable language_">self</span>.num_heads=num_heads</span><br><span class="line">        <span class="variable language_">self</span>.head_dim=embed_dim//num_heads</span><br><span class="line">        <span class="variable language_">self</span>.proj_q=nn.Linear(embed_dim,embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.proj_k=nn.Linear(embed_dim,embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.proj_v=nn.Linear(embed_dim,embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.out_proj=nn.Linear(embed_dim,embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.drop=nn.Dropout(dropout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        b,l,_=x.shape</span><br><span class="line">        q = <span class="variable language_">self</span>.proj_q(x).reshape(b, l, <span class="variable language_">self</span>.num_heads, <span class="variable language_">self</span>.head_dim).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        k = <span class="variable language_">self</span>.proj_k(x).reshape(b, l, <span class="variable language_">self</span>.num_heads, <span class="variable language_">self</span>.head_dim).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        v = <span class="variable language_">self</span>.proj_v(x).reshape(b, l, <span class="variable language_">self</span>.num_heads, <span class="variable language_">self</span>.head_dim).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        atten_score=torch.matmul(q,k.transpose(-<span class="number">2</span>,-<span class="number">1</span>))/<span class="variable language_">self</span>.head_dim**<span class="number">0.5</span></span><br><span class="line">        atten_weight=torch.nn.functional.softmax(atten_score,dim=-<span class="number">1</span>)</span><br><span class="line">        atten_weight = <span class="variable language_">self</span>.drop(atten_weight)</span><br><span class="line">        atten = torch.matmul(atten_weight, v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(b, l, <span class="variable language_">self</span>.embed_dim)</span><br><span class="line">        out=<span class="variable language_">self</span>.out_proj(atten)</span><br><span class="line">        out=<span class="variable language_">self</span>.drop(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 多层感知机块 (MLP Block)</span></span><br><span class="line"><span class="comment"># 模块： MlpBlock(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MlpBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,embed_dim,mlp_dim,out_dim,dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.fc1=nn.Linear(embed_dim,mlp_dim)</span><br><span class="line">        <span class="variable language_">self</span>.fc2=nn.Linear(mlp_dim,out_dim)</span><br><span class="line">        <span class="variable language_">self</span>.act=nn.GELU()</span><br><span class="line">        <span class="variable language_">self</span>.drop=nn.Dropout(dropout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=<span class="variable language_">self</span>.fc1(x)</span><br><span class="line">        x=<span class="variable language_">self</span>.act(x)</span><br><span class="line">        x=<span class="variable language_">self</span>.drop(x)</span><br><span class="line">        x=<span class="variable language_">self</span>.fc2(x)</span><br><span class="line">        out=<span class="variable language_">self</span>.drop(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Transformer 编码器块 (Transformer Encoder Block)</span></span><br><span class="line"><span class="comment"># 模块： TransformerEncoderBlock(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerEncoderBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,embed_dim,num_heads,mlp_dim,dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.norm1=nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.norm2=nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.mlp = MlpBlock(embed_dim, mlp_dim, embed_dim, dropout) </span><br><span class="line">        <span class="variable language_">self</span>.msa = MultiHeadSelfAttention(embed_dim, num_heads, dropout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        norm=<span class="variable language_">self</span>.norm1(x)</span><br><span class="line">        msa=<span class="variable language_">self</span>.msa(norm)</span><br><span class="line">        res=msa+x</span><br><span class="line">        norm=<span class="variable language_">self</span>.norm2(res)</span><br><span class="line">        mlp=<span class="variable language_">self</span>.mlp(norm)</span><br><span class="line">        out=mlp+res</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Transformer 编码器 (Transformer Encoder)</span></span><br><span class="line"><span class="comment"># 模块： TransformerEncoder(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerEncoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,embed_dim,num_heads,mlp_dim,depth,dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.layers=nn.ModuleList([])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(depth): </span><br><span class="line">            layer = TransformerEncoderBlock(embed_dim, num_heads, mlp_dim, dropout)</span><br><span class="line">            <span class="variable language_">self</span>.layers.append(layer)</span><br><span class="line">        <span class="variable language_">self</span>.norm=nn.LayerNorm(embed_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers: </span><br><span class="line">            x = layer(x) </span><br><span class="line">        out=<span class="variable language_">self</span>.norm(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 完整的 Vision Transformer (ViT) 模型</span></span><br><span class="line"><span class="comment"># 模块： VisionTransformer(nn.Module)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisionTransformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,image_size,in_channels,num_classes,patch_size,embed_dim,depth,num_heads,mlp_dim,dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.emb=PatchEmbedding(in_channels,patch_size,embed_dim,image_size)</span><br><span class="line">        <span class="variable language_">self</span>.trans=TransformerEncoder(embed_dim,num_heads,mlp_dim,depth,dropout)</span><br><span class="line">        <span class="variable language_">self</span>.lin=nn.Linear(embed_dim,num_classes)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        emb=<span class="variable language_">self</span>.emb(x)</span><br><span class="line">        trans_output=<span class="variable language_">self</span>.trans(emb)</span><br><span class="line">        cls_token_output = trans_output[:, <span class="number">0</span>]</span><br><span class="line">        out=<span class="variable language_">self</span>.lin(cls_token_output)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手撕代码 </category>
          
          <category> Vision Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vit </tag>
            
            <tag> 手撕代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoE</title>
      <link href="/2025/04/MOE/"/>
      <url>/2025/04/MOE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Mixtures of Experts</h1><h2 id="《Adaptive-Mixture-of-Local-Experts》">《Adaptive Mixture of Local Experts》</h2><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501100302213.png" style="zoom:50%;" /><p>论文链接：<a href="https://www.cs.toronto.edu/~hinton/absps/jjnh91.pdf">https://www.cs.toronto.edu/~hinton/absps/jjnh91.pdf</a></p><p>1991年，由 Hinton和 Jordan提出，这是最早的MoE架构。</p><p>核心思想：通过多个独立专家网络处理输入数据不同子集，并由门控网络动态选择专家。<strong>每个专家接受相同的输入数据</strong>，但通过门控网络的动态分配，专家会专注于处理输入空间的特定区域。</p><h3 id="基础架构">基础架构</h3><p>如图，一个由专家网络和门控网络组成的系统。每个专家是一个前馈网络，所有专家接收相同的输入，并具有相同数量的输出。门控网络也是一个前馈网络，通常接收与专家网络相同的输入。它的输出是归一化的 $ p_j = \exp(r_j) / \sum_i \exp(r_i) $，其中 $ r_j $是门控网络输出单元 $j$ 接收的总加权输入。选择器（selector）类似于一个多输入单输出的随机开关；开关选择来自专家 $ j $ 的输出的概率为 $p_j$ 。每个专家通常只会被分配到可能输入向量空间的一个小区域内。</p><p>系统由多个专家网络和一个门控网络组成。每个专家是一个前馈网络，处理特定子任务；门控网络根据输入决定每个专家的混合比例（概率）。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501113347385.png" style="zoom:50%;" /><p>通过重新定义误差函数，鼓励专家竞争而非协作，确保每个专家专注于特定子任务。传统误差函数（如均方误差）会导致专家协作，增加耦合；论文提出优比损失（基于高斯混合模型的负对数概率），使专家独立学习，减少干扰。改进后的误差函数使门控网络倾向于选择最适合的专家，加快收敛。</p><h3 id="性能比较">性能比较</h3><p>元音辨别：区分多说话者元音区分（识别元音 [i], [I], [a], [A]）。</p><p><strong>数据集</strong>：来自 75 个说话者的共振峰数据（Peterson 和 Barney, 1952），前 50 个用于训练，后 25 个用于测试。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501110027054.png" style="zoom:60%;" /><p>模型能自动分解任务，专注于不同类别对（如 [i]/[I] 和 [a]/[A]），仅 2-3 个专家在最终混合中活跃。</p><p>混合专家模型达到误差标准明显快于反向传播网络，平均只需要大约一半的周期数。混合模型的学习时间也随着专家数量的增加而很好地扩展。混合专家模型具有较小但统计上显著的平均周期数优势。</p><h3 id="总结">总结</h3><p>这篇论文针对的问题是在不同场合执行不同任务会产生干扰，导致训练速度慢和泛化性能差。MoE 的核心思想是让专家专注于适合的子任务。这意味着某些专家的利用率较低（论文中提到最终只有 2-3 个专家活跃），后续的论文大多都是在解决这个问题。</p><p>论文展示了 MoE 模型的任务分解过程：初始阶段，门控网络给所有专家分配相等的混合比例，导致每个专家处理的案例数量大致相等，决策线趋向于处理所有案例的平均最优解。随着训练进行，竞争机制使专家分化，专注于特定子任务，从而形成更符合数据分布的最优决策面。这种机制显著减少了干扰，训练速度比反向传播网络快约 50%，体现了 MoE 架构在训练时间上的优势。</p><h2 id="《Outrageously-Large-Neural-Networks-The-Sparsely-Gated-Mixture-of-Experts-Layer》">《Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer》</h2><p>超大型神经网络：稀疏门控混合专家层</p><p>论文链接：<a href="https://arxiv.org/abs/1701.06538">https://arxiv.org/abs/1701.06538</a></p><p>2017年，合作作者中还有Hinton和 Jordan，在LSTM层之间应用MoE卷积。仅以微小的计算效率损失就取得了超过 1000 倍的模型容量提升，并在公共语言建模和翻译数据集上显著提升了最先进的结果。</p><p>上一篇强调的是减小时间成本，这一篇是减小计算成本。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501141207768.png" style="zoom:40%;" /><h3 id="基础架构-2">基础架构</h3><h4 id="稀疏门控专家混合层（MoE）">稀疏门控专家混合层（MoE）</h4><p>MoE 由很多专家组成，每个专家相当于一个前馈神经网络。以及一个可训练的门控网络，该网络选择专家的稀疏组合来处理每个输入。网络的所有部分都通过反向传播进行联合训练。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501165106468.png" style="zoom:30%;" /><p>设 $ G(x) $和 $ E_i(x) $ 分别为给定输入 $ x $ 的门控网络输出和第 $ i $ 个专家网络的输出。MoE 模块的输出 $ y $ 可表示为：<br>$$<br>y = \sum_{i=1}^{n} G(x)_i E_i(x)<br>$$</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501192052114.webp" style="zoom:38%;" /><h3 id="均衡负载">均衡负载</h3><p>门控网络总是倾向于收敛到一种状态，在这种状态下，它总是对同一批专家产生较大的权重，使得被偏好的专家训练得更快，更容易被门控网络选中。希望在训练和推理过程中，专家的重要性相等，称之为<strong>负载平衡</strong> 。某种程度上，这是为了防止对同一个专家过度拟合。</p><h4 id="Keep-Top-K">Keep Top-K</h4><p><strong>Noisy Top-K Gating</strong></p><p>添加了两个组件：<strong>稀疏性和噪音</strong>。在应用 Softmax 函数之前，添加可调的高斯噪声，然后仅保留前 $ k $ 个值，将其余值设为 $-\infty$（这会导致对应的门控值为 0）。每部分的噪声量由可训练权重矩阵 $ W_{\text{noise}} $ 控制。通过简单的反向传播训练门控网络。<strong>稀疏性用于节省计算，噪声项有助于负载均衡。</strong></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250501192435690.webp" style="zoom:33%;" /><h5 id="Noise">Noise</h5><p>使用Noisy Top-K Gating方法改进MoE层，引入可训练的 Gaussian 噪声防止总是选择相同的专家。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502135639110.webp" style="zoom:50%;" />$$H(x)_i = (x \cdot W_g)_i + \text{StandardNormal}() \cdot \text{Softplus}((x \cdot W_{\text{noise}})_i)$$<h5 id="Sparse">Sparse</h5><p>除了想要激活的前 k 名专家之外，其他所有专家的权重都将设置为 $-\infty$ 。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502140128737.png" style="zoom:50%;" />$$\text{KeepTopK}(v, k)_i =\begin{cases}v_i & \text{if } v_i \text{ is in the top } k \text{ elements of } v, \\\-\infty & \text{otherwise}.\end{cases}$$通过将这些权重设置为 $-\infty$ ，SoftMax 在这些权重上的输出将产生概率 0 ：<img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502140429369.webp" style="zoom:50%;" />$$G(x) = \text{Softmax}(\text{KeepTopK}(H(x), k))$$<p>KeepTopK 策略将每个 token 路由给几个选定的专家。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502140803358.webp" style="zoom:50%;" /><h4 id="Auxiliary-Loss">Auxiliary Loss</h4><p>为了在训练过程中获得更均匀的专家分布，辅助损失（也称为<em>负载平衡损失</em> ）被添加到网络的常规损失中。它增加了一个约束，迫使专家具有同等重要性。</p><p>该辅助损失的第一个组成部分是将整个批次中每个专家的门控值相加。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502133715717.png" style="zoom:50%;" />$$\text{Importance}(X) = \sum_{x \in X} G(x) $$这为我们提供了每个专家的重要性分数 ，该分数表示无论输入如何，选择特定专家的可能性。可以用它来计算变异系数 （ CV ），它告诉我们专家之间重要性得分的差异有多大。利用这个 CV 分数，我们可以在训练期间更新辅助损失 ，以尽可能降低 CV 分数（ 从而给予每个专家同等的重要性 ）。<img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502134023343.webp" style="zoom:50%;" /><p>如果重要性分数存在很大差异，则 CV 会很高，相反，如果所有专家的重要性得分都相似，那么 CV 就会较低</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502134637067.webp" style="zoom:50%;" />$$L_{\text{importance}}(X) = w_{\text{importance}} \cdot CV(\text{Importance}(X))^2$$最后，将辅助损失作为单独的损失添加，以便在训练期间进行优化。<p>虽然这种损失函数可以确保平衡的重要性，但专家仍然可能收到数量非常不同的样本。为了解决这一问题，论文引入了 $ L_{\text{load}} $ 损失，专门用于平衡专家接收的样本数量（即负载均衡），与 $ L_{\text{importance}} $ 损失（平衡门控权重总和）配合使用。</p><h4 id="Load-Balancing-Loss">Load-Balancing Loss</h4><p>专家接收的样本数量是一个离散值，无法用于反向传播。所以这里定义了一个平滑估计器 $Load(X)$，用于估计每个专家在输入批次 $X$ 中分配到的示例数量，通过概率计算来近似样本分配。平滑性使得可以通过估计器反向传播梯度。这是门控函数中噪声项的目的。</p><p>对于一个输入批次 $ X $，第 $ i $ 个专家的负载定义为：<br>$$ {Load}(X)_i = \sum_{x \in X} P(x, i)$$ <br>其中 $ P(x, i) $ 是给定输入 $ x $ 时第 $ i $ 个专家被选中的概率，它描述了第 $ i$ 个专家的“带噪声得分”大于某个阈值的概率。论文通过噪声 Top-K 门控的特性计算 $ P(x, i) $：<br>$$ P(x, i) = \Pr\left( (x \cdot W_g)_i + \text{StandardNormal}() \cdot \text{Softplus}((x \cdot W_{\text{noise}})_i) > k{th\_excluding}(H(x), k, i) \right)$$ <br><strong>$ (x \cdot W_g)_i $</strong>：</p><ul><li>$x $ 是输入向量（例如来自上一层的 LSTM 输出）。</li><li>$ W_g $ 是门控网络的可训练权重矩阵。</li><li>$ (x \cdot W_g)_i $ 是第 $ i $ 个专家的原始得分（未添加噪声），表示门控网络对第 $ i $ 个专家的“偏好”。</li></ul><p><strong>$ StandardNormal()⋅Softplus((x⋅Wnoise)i) $</strong>：</p><ul><li><strong>$ \text{StandardNormal}() $</strong>：表示从均值为 0、标准差为 1 的标准正态分布中采样一个随机数。</li><li><strong>$ (x \cdot W_{\text{noise}})_i $</strong>：通过另一个可训练权重矩阵$ W_{\text{noise}} $ 计算的噪声控制项。</li><li><strong>$ \text{Softplus}((x \cdot W_{\text{noise}})_i) $</strong>：这部分计算噪声的标准差。它通过将输入 $x$ 与另一个可训练的权重矩阵 $W_{noise}$ 相乘，然后应用 Softplus 函数 $ \text{Softplus}(z) = \log(1 + e^z) $ 来确保标准差为正值。这个标准差是可调节的，并且依赖于输入 $x$ 。</li><li>这部分是加到原始得分上的高斯噪声，表示一个高斯噪声项，均值为 0，方差由 $ \text{Softplus}((x \cdot W_{\text{noise}})_i) $决定。噪声的引入有助于负载均衡，避免门控网络总是选择固定的专家。</li></ul><p>$$ H(x)_ i = (x \cdot W_g)_i + \text{StandardNormal}() \cdot \text{Softplus}((x \cdot W_{\text{noise}})_i$$ </p><p>$H(x)_i$代表了第$ i $个专家的最终“带噪声得分”。</p><p><strong>$k\text{th_excluding}(H(x), k, i)$</strong>: 这是决定专家 i 是否被选中的阈值。它的含义是：在向量 $H(x)$（包含了所有专家的带噪声得分）中，排除掉第 i 个专家自身的分数后，找到剩下 n−1 个分数中第 k 大的分数 。</p><p>$Pr(⋯&gt;…): $ 公式计算  $ H(x)_ i $（重新采样噪声后）大于  $k\text{th_excluding}(H(x), k, i)$ 的概率。在噪声 Top-K 门控中，第 $𝑖$ 个专家被选中当且仅当 $ H(x)_ i$ 是 $𝐻 ( 𝑥 )$ 中前 $𝑘$ 大的值。<br>$$ P(x, i) = \Phi\left( \frac{(x \cdot W_g)_i - k{th\_ excluding}(H(x), k, i)}{\text{Softplus}((x \cdot W_{\text{noise}})_i)} \right)$$ <br>Φ 表示标准正态分布的累积分布函数（CDF）。利用正态分布的 CDF 给出了计算这个概率的具体数学表达式，方便进行计算和反向传播（因为 Φ 是可微的）。这整个机制是为了在选择专家时引入随机性（有助于负载均衡 ）并估算每个专家被选中的概率，进而定义$L_{load}$损失。<br>$$ L_{\text{load}}(X) = w_{\text{load}} \cdot CV(\text{Load}(X))^2$$ <br>初始负载不平衡：为了避免内存溢出错误，需要在近似相等的专家负载状态下初始化网络（因为软约束需要一些时间才能发挥作用）。为了实现这一点，将矩阵 $W_g$ 和 $W_{noise}$ 初始化为全零，这样就不会产生信号，而只有一些噪声。</p><h4 id="Hierarchical-Mixture-of-Experts">Hierarchical Mixture-of-Experts</h4><p>层次 MoE 是一种分层结构的 MoE，如果专家数量非常庞大，可以使用两层分层MoE来降低分支因子。在一个分层MoE中，一个主门控网络选择一个稀疏加权组合的“专家”，每个“专家”本身就是一个具有自己门控网络的二级混合专家。</p><p><strong>第一级（主门控网络）</strong>：主门控网络 $ G_{\text{primary}} $ 负责选择一组“专家组”（groups of experts）。</p><p><strong>第二级（次级门控网络）</strong>：每个专家组内有一个次级门控网络 $G_i $，负责在该组内选择具体的专家。</p><p><strong>专家网络</strong>：最终的专家网络 $E_{i,j} $，其中 $ i $ 表示组索引，$j $ 表示组内的专家索引。<br>$$ y_H = \sum_{i=1}^{a} \sum_{j=1}^{b} G_{\text{primary}}(x)_i \cdot G_i(x)_j \cdot E_{i,j}(x)$$ <br>$Gprimary(x)i$：主门控网络对第 $ i $ 个组的权重。</p><p>$G_i(x)_j $：第 $ i $ 个组的次级门控网络对组内第 $j $ 个专家的权重。</p><p>$ E_{i,j}(x) $：第 $ i $ 个组中第 $j $ 个专家的输出。</p><p>对专家利用率的衡量指标将更改为以下内容：<br>$$ \text{Importance}_H(X)_{i,j} = \sum_{x \in X} G_{\text{primary}}(x)_i \cdot G_i(x)_j$$ </p><p>$$ \text{Load}_H(X)_{i,j} = \frac{\text{Load}_{\text{primary}}(X)_i \cdot \text{Load}_i(X^{(i)})_j}{|X^{(i)}|}$$ </p><p>$Load_{primary}$   和 $Load_i$ 分别表示主门控网络和 $i^{th}$ 次级门控网络的加载函数。 $ X^{(i)}$表示 X 中满足 $ G_{primary}(x)_i &gt; 0 $ 的子集。</p><h2 id="《GShard-Scaling-Giant-Models-with-Conditional-Computation-and-Automatic-Sharding》">《GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding》</h2><p>基于条件计算和自动分片的巨型模型扩展。</p><p>论文链接：<a href="https://arxiv.org/abs/2006.16668">https://arxiv.org/abs/2006.16668</a></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502231628278.png" style="zoom:30%;" /><h3 id="创新点">创新点</h3><h4 id="Expert-Capacity">Expert Capacity</h4><p>专家容量</p><p>不平衡不仅存在于所选专家中，还存在于发送给专家的token分配中。如果输入 token 不成比例地发送给一个专家而不是另一个专家，那么也可能导致训练不足。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502134823180.webp" style="zoom:50%;" /><p>解决这个问题的一个方法是限制每个专家可以处理的 token 数量，即专家容量 。当专家达到容量上限时，产生的 token 将被发送给下一个专家：</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502134935242.webp" style="zoom:50%;" /><p>如果两个专家都已达到其容量上限，则 token 将不会被任何专家处理，而是被发送到下一层。这称为 token 溢出 。这些token的表示通过残差连接传递到下一层。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502135022720.webp" style="zoom:50%;" /><h4 id="Auxiliary-loss">Auxiliary loss</h4><p>门控函数不应总是选择相同的一小部分专家，因为这会导致一小部分专家容量溢出，而其余专家则被闲置。定义了一个辅助损失项 ℓaux 来强制执行此约束。 它被添加到模型的总损失函数中 L = ℓnll + k ∗ ℓaux，其中 k 是一个常数乘数。</p><h4 id="Random-routing">Random routing</h4><p>随机路由机制</p><p>在 top-2 设计中，始终选择表现最优的专家，但第二选择的专家则根据其权重以一定概率被选中。</p><h2 id="《Switch-Transformers-Scaling-to-Trillion-Parameter-Models-with-Simple-and-Eﬃcient-Sparsity》">《Switch Transformers: Scaling to Trillion Parameter Models with Simple and Eﬃcient Sparsity》</h2><p>论文链接：<a href="https://arxiv.org/abs/2101.03961">https://arxiv.org/abs/2101.03961</a></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250505161645576.png" style="zoom:35%;" /><p>简化了MoE路由算法，并设计了直观的改进模型，从而降低了通信和计算成本。提出的训练技术减轻了不稳定性，并且证明了可以使用较低精度（bfloat16）格式首次训练大型稀疏模型。将 Switch 层添加到 Transformer 的自注意力层中。</p><h3 id="Switch-Routing">Switch Routing</h3><p>（1）仅将token路由到单个专家，因此减少了路由器计算。</p><p>（2）由于每个token仅被路由到单个专家，因此每个专家的批次大小（专家容量）可以至少减半。</p><p>（3）路由实现得到简化，并且通信成本降低。</p><h2 id="《DeepSeekMoE-Towards-Ultimate-Expert-Specialization-in-Mixture-of-Experts-Language-Models》">《DeepSeekMoE: Towards Ultimate Expert Specialization in Mixture-of-Experts Language Models》</h2><h3 id="现有MoE架构问题">现有MoE架构问题</h3><p>（1）知识混合性：现有的MoE实践通常采用数量有限的专家（例如，8个或16个），因此分配给特定专家的token可能涵盖各种知识。因此，指定的专家将倾向于在其参数中组合截然不同的知识类型，而这些知识很难同时利用。</p><p>（2）知识冗余：分配给不同专家的token可能需要共同的知识。因此，多个专家可能会收敛于在其各自的参数中获取共享知识，从而导致专家参数的冗余。</p><p>这些问题共同阻碍了现有MoE实践中的专家专业化，使其无法达到MoE模型的理论性能上限。</p><p>我个人感觉第一个问题和第一篇论文提出的目的应该是一致的，一个模型在不同场合执行不同任务会产生干扰，然后这里的专家又出现了这个问题，使得专家的专业化程度较低。</p><h3 id="解决问题的主要策略">解决问题的主要策略</h3><p>（1）细粒度专家分割：在保持参数数量不变的同时，我们通过分割 FFN 中间隐藏维度将专家分割成更细的粒度。相应地，在保持恒定计算成本的同时，我们也激活更多细粒度的专家，以实现激活专家的更灵活和适应性更强的组合。细粒度的专家分割使得不同的知识能够被更精细地分解，并被更精确地学习到不同的专家中，其中每个专家将保持更高的专业化水平。此外，激活专家组合的灵活性增加也有助于更准确和有针对性的知识获取。</p><p>（2）共享专家隔离：我们隔离某些专家作为始终激活的共享专家，旨在捕获和巩固不同上下文中的通用知识。通过将通用知识压缩到这些共享专家中，其他路由专家之间的冗余将被减轻。这可以提高参数效率，并确保每个路由专家通过专注于独特的方面来保持专业性。</p><p>DeepSeekMoE 中的这些架构创新为训练参数高效的 MoE 语言模型提供了机会，其中每个专家都高度专业化。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502145719363.png" style="zoom:40%;" /><p>DeepSeekMoE 的示意图。子图 (a) 展示了具有传统 top-2 路由策略的 MoE 层。子图 (b) 说明了细粒度专家分割策略。子图 © 展示了共享专家隔离策略的集成，构成了完整的 DeepSeekMoE 架构。值得注意的是，在这三种架构中，专家参数的数量和计算成本保持不变。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250502161913940.png" style="zoom:40%;" /><h3 id="DeepSeekMoE-架构">DeepSeekMoE 架构</h3><h4 id="细粒度专家分割">细粒度专家分割</h4><p>通过将FFN中间隐藏维度降低到原始大小的𝑚分之一，将每个专家FFN分割成𝑚个更小的专家。由于每个专家变得更小，作为回应，还将激活专家的数量增加到𝑚倍，以保持相同的计算成本。通过细粒度的专家分割，MoE层的输出可以表示为：<br>$$ \mathbf{h}_t^l = \sum_{i=1}^{mN} (g_{i,t} \cdot \text{FFN}_i(\mathbf{u}_t^l)) + \mathbf{u}_t^l$$ </p><p>$$<br>g_{i,t} = \begin{cases}<br>s_{i,t}, &amp; s_{i,t} \in \text{Topk}({s_{j,t}} \mid 1 \leq j \leq mN), mK), \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p><p>$$<br>s_{i,t} = \text{Softmax}_i(\mathbf{u}_t^{l^T} \mathbf{e}_i^l)<br>$$</p><p>其中，专家参数的总数等于 𝑁 乘以标准 FFN 中的参数数量，mN 表示细粒度专家的总数。采用细粒度专家分割策略后，非零门控的数量也将增加到 mK。</p><p>组合灵活性的激增增强了实现更准确和更有针对性的知识获取的潜力。</p><h4 id="共享专家隔离">共享专家隔离</h4><p>采用传统的路由策略，分配给不同专家的令牌可能需要一些共同的知识或信息。因此，多个专家可能会趋同于在其各自的参数中获取共享知识，从而导致专家参数的冗余。然而，如果存在专门用于捕获和整合不同上下文中的共同知识的共享专家，则可以减轻其他路由专家之间的参数冗余。这种冗余的减轻将有助于构建一个参数效率更高、专家更专业的模型。</p><p>隔离𝐾𝑠个专家作为共享专家。无论路由器模块如何，每个token都将被确定性地分配给这些共享专家。为了保持恒定的计算成本，其他路由专家中激活的专家数量将减少𝐾𝑠。通过集成共享专家隔离策略，完整DeepSeekMoE架构中的MoE层可以表述如下：<br>$$ \mathbf{h}_t^l = \sum_{i=1}^{K_s} \text{FFN}_i(\mathbf{u}_t^l) + \sum_{i=K_s+1}^{mN} (g_{i,t} \cdot \text{FFN}_i(\mathbf{u}_t^l)) + \mathbf{u}_t^l$$ </p><p>$$<br>g_{i,t} = \begin{cases}<br>s_{i,t}, &amp; s_{i,t} \in \text{Topk}({s_{j,t} \mid K_s + 1 \leq j \leq mN }), mK - K_s), \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p><p>$$<br>s_{i,t} = \text{Softmax}_i(\mathbf{u}_t^{l^T} \mathbf{e}_i)<br>$$</p><p>最后，在 DeepSeekMoE 中，共享专家的数量为 𝐾𝑠，路由专家的总数为 𝑚𝑁 − 𝐾𝑠，非零门的数量为 𝑚𝐾 − 𝐾𝑠。</p><h4 id="负载均衡问题">负载均衡问题</h4><p>自动学习的路由策略可能会遇到负载不均衡的问题，这表现出两个显著的缺陷。首先，存在路由崩溃的风险，即模型总是只选择少数几个专家，导致其他专家无法得到充分的训练。其次，如果专家分布在多个设备上，负载不均衡会加剧计算瓶颈。</p><h5 id="Expert-Level-Balance-Loss">Expert-Level Balance Loss</h5><p>专家级平衡损失。为了降低路由崩溃的风险，平衡损失的计算如下：<br>$$ \mathcal{L}_{\text{ExpBal}} = \alpha_1 \sum_{i=1}^{N'} f_i p_i$$ </p><p>$$<br>f_i = \frac{N’}{K’ T} \sum_{t=1}^{T} \mathbb{1}(\text{Token } t \text{ selects Expert } i)<br>$$</p><p>$$<br>p_i = \frac{1}{T} \sum_{t=1}^{T} s_{i,t}<br>$$</p><p>其中𝛼1是一个被称为专家级别平衡因子的超参数，为了简洁起见，𝑁′等于(𝑚𝑁 − 𝐾𝑠)，𝐾′等于(𝑚𝐾 − 𝐾𝑠)。1(·)表示指示函数。</p><h5 id="Device-Level-Balance-Loss">Device-Level Balance Loss</h5><p>将所有路由的专家划分为 𝐷 组 {E1, E2, . . ., E𝐷}，并将每组部署在单个设备上，则设备级别平衡损失的计算方式如下：<br>$$ \mathcal{L}_{\text{DevBal}} = \alpha_2 \sum_{i=1}^{D} f'_i p'_i$$ </p><p>$$ f'_i = \frac{1}{|\mathcal{E}_i|} \sum_{j \in \mathcal{E}_i} f_j$$ </p><p>$$ p'_i = \sum_{j \in \mathcal{E}_i} p_j$$ </p><p>其中𝛼2是一个被称为设备级别平衡因子的超参数。设置一个较小的专家级别平衡因子以降低路由崩溃的风险，同时设置一个较大的设备级别平衡因子以促进设备间的均衡计算。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> MOE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> 混合专家系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoCo</title>
      <link href="/2025/04/MoCo/"/>
      <url>/2025/04/MoCo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MoCo">MoCo</h2><p>Momentum Contrast for Unsupervised Visual Representation Learning  (cvpr2020)</p><p>论文地址：<a href="https://arxiv.org/pdf/1911.05722">https://arxiv.org/pdf/1911.05722</a></p><p>代码地址：<a href="https://github.com/facebookresearch/moco">https://github.com/facebookresearch/moco</a></p><h3 id="概述">概述</h3><img src="https://user-images.githubusercontent.com/11435359/71603927-0ca98d00-2b14-11ea-9fd8-10d984a2de45.png" style="zoom:60%;" /><p>MoCo 将对比学习看作是一个<strong>字典查找</strong>任务 ：一个编码后的查询（query）应该与其匹配的键（正样本）相似，而与其他所有的键（负样本）不相似 。</p><p>对比学习的核心思想是训练一个编码器，使其能够区分相似（正样本）和不相似（负样本）的样本 。</p><h3 id="传统方法-VS-MoCo">传统方法 VS MoCo</h3><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250425170023257.png" style="zoom:40%;" /><p><strong>端到端（End-to-end）方法</strong>（SimCLR，Inva Spread）：将当前 mini-batch 内的样本作为字典 。这种方法的优点是字典中的键编码是一致的（由同一个编码器生成），但缺点是字典的大小受限于 mini-batch 的大小，而 mini-batch 大小又受限于 GPU 内存 。过大的 mini-batch 也会带来优化难题 。</p><p><strong>Memory Bank 方法</strong>（Inst Disc）：Memory Bank包含数据集所有数据的特征表示，从Memory Bank中采样数据不需要进行反向传播，所以能支持比较大的字典，然而一个样本的特征表示只在它出现时才在Memory Bank更新，所以一个epoch只会更新一次，但模型在训练过程中不断迭代，这个特征就会“过时”，因此具有更少的一致性，而且它的更新只是进行特征表示的更新，不涉及encoder。</p><p>MoCo跟Inst Disc是非常相似的，比如它用队列取代了原来的memory bank作为一个额外的数据结构去存储负样本，用动量编码器去取代了原来loss里的约束项，这样就可以动量的更新编码器，而不是动量的去更新特征，从而能得到更好的结果。其整体的出发点以及一些实现的细节（比如backbone和lr、batch_size，dim、τ等等超参数都是一样的）和Inst Disc都是非常类似的，所以可以说MoCo是Inst Disc的改进工作。</p><h3 id="创新点">创新点</h3><p>MoCo 通过两个创新点解决了这一问题：<strong>基于队列的动态字典</strong>和<strong>动量编码器</strong>，给无监督的对比学习构造了一个又大又一致的字典。</p><h4 id="基于队列的动态字典">基于队列的动态字典</h4><p>MoCo 使用一个队列来存储图像表征（称为键），作为动态字典。通过这种“先进先出”的更新方式，队列始终保持固定的大小，并且包含的是相对较新的样本表示，有助于维持字典的一致性。队列可以容纳 65,536 个键，为对比学习提供了丰富的负样本集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">f_k.params = f_q.params <span class="comment"># 初始化</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> loader: <span class="comment"># 输入一个图像序列x，包含N张图，没有标签</span></span><br><span class="line">    x_q = aug(x) <span class="comment"># 用于查询的图（数据增强得到）</span></span><br><span class="line">    x_k = aug(x) <span class="comment"># 模板图（数据增强得到），自监督就体现在这里，只有图x和x的数据增强才被归为一类</span></span><br><span class="line">    q = f_q.forward(x_q) <span class="comment"># 提取查询特征，输出NxC</span></span><br><span class="line">    k = f_k.forward(x_k) <span class="comment"># 提取模板特征，输出NxC</span></span><br><span class="line">    <span class="comment"># 不使用梯度更新f_k的参数，这是因为文章假设用于提取模板的表示应该是稳定的，不应立即更新</span></span><br><span class="line">    k = k.detach() </span><br><span class="line">    <span class="comment"># 这里bmm是分批矩阵乘法</span></span><br><span class="line">    l_pos = bmm(q.view(N,<span class="number">1</span>,C), k.view(N,C,<span class="number">1</span>)) <span class="comment"># 输出Nx1，也就是自己与自己的增强图的特征的匹配度</span></span><br><span class="line">    l_neg = mm(q.view(N,C), queue.view(C,K)) <span class="comment"># 输出Nxk，自己与上一批次所有图的匹配度（全不匹配）</span></span><br><span class="line">    logits = cat([l_pos, l_neg], dim=<span class="number">1</span>) <span class="comment"># 输出Nx(1+k)</span></span><br><span class="line">    labels = zeros(N)</span><br><span class="line">    <span class="comment"># NCE损失函数，就是为了保证自己与自己衍生的匹配度输出越大越好，否则越小越好</span></span><br><span class="line">    loss = CrossEntropyLoss(logits/t, labels) </span><br><span class="line">    loss.backward()</span><br><span class="line">    update(f_q.params) <span class="comment"># f_q使用梯度立即更新</span></span><br><span class="line">    <span class="comment"># 由于假设模板特征的表示方法是稳定的，因此它更新得更慢，这里使用动量法更新，相当于做了个滤波。</span></span><br><span class="line">    f_k.params = m*f_k.params+(<span class="number">1</span>-m)*f_q.params </span><br><span class="line">    enqueue(queue, k) <span class="comment"># 为了生成反例，所以引入了队列</span></span><br><span class="line">    dequeue(queue)</span><br></pre></td></tr></table></figure><h4 id="动量编码器">动量编码器</h4><p>MoCo 使用两个编码器：<strong>查询编码器</strong>（query encoder）和<strong>键编码器</strong>（key encoder）。查询编码器通过反向传播正常更新，而键编码器是查询编码器的缓慢更新版本，其参数通过动量机制更新。具体来说，键编码器的参数是其之前参数与查询编码器参数的加权平均，动量系数（momentum coefficient）通常设为 0.999，使得键编码器变化非常缓慢。这种稳定性保证了队列中键的表征不会因编码器快速变化而失去一致性。<br>$$<br>\theta_k \leftarrow m \theta_k + (1-m) \theta_q<br>$$</p><p><code>query</code>的编码器和<code>key</code>的编码器既可以是相同的（模型的架构一样，参数完全共享，比如Inva Spread），或者说它们的参数是部分共享的，也可以是彻底不一样的两个网络（CMC，多视角多编码器）。</p><h3 id="Pretext-Task（代理任务）">Pretext Task（代理任务）</h3><p>论文中主要采用了一个简单的实例判别任务（Instance Discrimination）：如果一个查询和一个键来源于同一张图片的不同随机增强视图（例如，不同的裁剪、颜色抖动等），则它们构成一个正样本对；否则构成负样本对 。编码器（如 ResNet ）将这些视图编码为特征向量，然后通过 InfoNCE 损失函数进行优化 。</p><h3 id="损失函数">损失函数</h3><p>在对比学习中，最常用的目标函数是 <strong>InfoNCE 损失</strong>（Noise-Contrastive Estimation 的信息理论扩展）。InfoNCE 损失基于互信息最大化的思想，鼓励模型区分正样本对和负样本对。<br>$$<br>\mathcal L_{q} = - \log \frac{\exp(q \cdot k_{+} / \tau)}{\sum_{i=0}^{K} \exp(q \cdot k_{i} / \tau)}<br>$$<br>$ q $ 是查询的编码表示。</p><p>$ k_{+} $ 是正样本键的编码表示。</p><p>$ k_i $ 是字典中所有的键（包括一个正样本 $ k_{+} $ 和 K 个负样本）。</p><p>$ \tau $ 是超参数，用来控制分布的形状 ，去掉后整个式子其实就是交叉熵损失函数。</p><p>$ q \cdot k $ 表示点积相似度。</p><p><code>NCE loss</code>（<code>noise contrastive estimation</code> ）：将超级多分类转为二分类——数据类别data sample和噪声类别noisy sample。这样解决了类别多的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> MoCo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> 对比学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRMS</title>
      <link href="/2025/04/CSRMS/"/>
      <url>/2025/04/CSRMS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>CSRMS</h1><p>用于视觉表征学习的类级结构化关系建模与平滑 (MM2023)</p><p>论文地址：<a href="https://ercdm.sdu.edu.cn/__local/7/AC/70/7E4948C4761839F62E3958CE772_043AE854_2B459A.pdf">https://ercdm.sdu.edu.cn/__local/7/AC/70/7E4948C4761839F62E3958CE772_043AE854_2B459A.pdf</a></p><p>代码地址：<a href="https://github.com/czt117/CSRMS">https://github.com/czt117/CSRMS</a></p><p>个人理解这个像是一个知识总结的过程。首先通过特征提取获得特征图，这个过程可以类比我从书本上学习知识的过程，提取出有用的知识，然后通过聚类算法对特征图进行分簇，就相当于把学到的知识进行总结的过程，但是总会有一些比较相近的知识容易被搞混，这个就是类间相似性和类内多样性，再着重对这一块进行处理，使得对知识的掌握更加透彻。</p><p><strong>名词解释：</strong></p><p><strong>课程构建（Curriculum Construction）</strong>：是一种<strong>渐进式学习方法</strong>，通过根据任务或样本的难度或复杂性来设计学习顺序，让模型从简单的内容逐步过渡到复杂的内容，从而更高效地掌握知识。它通过评估样本难度、调整学习权重并动态控制训练过程，帮助模型更高效地学习，最终提高收敛速度和泛化能力。</p><p><strong>实例级别的图像（Instance-level images）</strong>：指的是针对单个具体图像样本的研究和处理。每一张图像被视为一个独立的实例，拥有其独特的特征和属性，而不是仅仅代表某个类别或群体的共性。与<strong>类别级别</strong>（Class-level）的研究不同，实例级别更关注图像的个体差异和细节。</p><p><strong>对比学习（Contrastive Learning）</strong>：是一种机器学习技术，特别在无监督学习和自监督学习中应用广泛。它的核心思想是通过对比不同样本之间的相似性和差异性，让模型自动学习数据的特征表示</p><h2 id="研究目的">研究目的</h2><p>缓解类内多样性和类间相似性问题</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250418224550763.png" style="zoom:40%;" /><h2 id="整体架构">整体架构</h2><p>CSRMS 框架的三个核心模块：<strong>类级关系建模</strong>、<strong>类感知图采样</strong> 和 <strong>关系图引导的表示学习</strong></p><p>在离线学习阶段，根据表征视觉分布挖掘类级关系，构建数据集级关系图；在训练阶段，根据类级关系构建多样化类感知采样策略，结合课程构建，获得Batch级别关系子图；在类级关系的引导下，利用特征平滑、类原型对齐和类级约束显式正则化视觉表征，有效缓解视觉表征分布复杂性。</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250418225319281.png" alt=""></p><h3 id="离线学习阶段">离线学习阶段</h3><h4 id="类级关系建模">类级关系建模</h4><h5 id="类级关系定义">类级关系定义</h5><p>(a) <strong>类内视觉模式的多样性（Intra-Class Diversity of Visual Patterns）</strong>：同一类别的样本分布在不同主导簇，说明类内样本视觉差异大。<br>$$<br>R_{ID} = \{ (I_a, I_b) \mid y_a = y_b, P_{C_a} \neq P_{C_b} \}<br>$$<br>(b) <strong>视觉模式的类间相似性 （Inter-Class Similarity of Visual Patterns）</strong>：不同类别的样本分布在同一主导簇，说明类间样本视觉上相似。<br>$$<br>R_{IS} = \{(I_a, I_b) \mid y_a \neq y_b, P_{C_a} = P_{C_b} \}<br>$$<br>© <strong>视觉模式的混类簇 (Mix-class Cluster of Visual Patterns)</strong>：不同类别的样本分布在同一混类簇，说明聚类结果复杂，缺乏主导类别。<br>$$<br>R_{MC} = \{(I_a, I_b) \mid y_a \neq y_b, M_{C_a} = M_{C_b} \}<br>$$</p><p><strong>主导簇（Dominant Clusters）</strong>：指聚类中主要由某个类别样本构成的簇，通常通过聚类算法基于特征分布确定。</p><p><strong>混类簇（Mix-class Clusters）</strong>：指聚类中没有明显主导类别的簇，包含多个类别的样本，增加了建模难度。</p><h5 id="ART聚类">ART聚类</h5><p><strong>自适应聚类算法 ART</strong>：能够根据数据分布动态调整簇数量，适合处理视觉特征空间中的复杂分布。对视觉特征进行聚类，得到视觉模式。$ C={c1,…,cJ}$<br>$$<br>C = ART(M_v(I))<br>$$<br>得到三个级别：类级别、模式级别、实例级别。然后构建关系图 $G_t$ 。这是一个多层图结构，实例级别连接到模式级别（通过聚类），模式级别连接到类级别（通过标签），这种结构有助于捕捉样本间的复杂关系。</p><h3 id="训练阶段">训练阶段</h3><h4 id="类感知图采样">类感知图采样</h4><h5 id="正样本采样">正样本采样</h5><p>使用主导模式采样器$ S_{dp} $，从类别 $ y_i $ 主导的最大簇 $c_j $ 中选择与 $ I_i $ 距离最大的前 $ n $个正样本。为每个批次样本选择正样本集合 $ \Omega_{posi} $，以解决类内多样性。</p><p>选择距离最远的正样本，增加类内样本的多样性，增强表征学习的鲁棒性。<br>$$<br>\Omega_{posi} = S_{dp}(I_i, \varphi(I_i, I_{i_j}), n)<br>$$</p><h5 id="负样本采样">负样本采样</h5><p>视觉相似模式采样器 $ S_{ap} $，从类别 $ y_i $ 主导的最大簇 $c_i $ 中选择与 $ I_i $ 距离最大的前 $m$个正样本。为每个批次样本选择负样本集合$\Omega_{nega} $，以解决类间相似性和混类簇。</p><p>选择视觉相似的负样本，增强类间区分度，缓解类间相似性问题。<br>$$<br>\Omega_{nega} = S_{ap}(I_i, \varphi(I_i, I_{i_j}), m)<br>$$</p><h5 id="课程学习">课程学习</h5><p>基于易难估计，为批次样本分配难度级别。<br>$$<br>f(I_i) = \begin{cases}<br>\Omega_{\text{easy}} &amp; \text{if } \frac{N_k^j}{N_k} &gt; \rho_1 \\<br>\Omega_{\text{medium}} &amp; \text{if } \frac{N_k^j}{N_k} &lt; \rho_1 \\<br>\Omega_{\text{hard}} &amp; \text{if } \frac{N_k^h}{N_k} &gt; \rho_1 \text{ and } j \neq h<br>\end{cases}<br>$$</p><h5 id="调整学习权重">调整学习权重</h5><p>使用“衰减方法”，设置惩罚系数，并通过参数调节。<br>$$<br>α_i⋅λ_e+(1−α_i)⋅(α_f⋅λ_m+(1−α_f)⋅λ_h)=1<br>$$<br>初期：$\alpha_i $、$ \alpha_f $接近 1，优先学习简单样本。</p><p>后期：当损失收敛（例如损失 &lt; 0.01 且连续两轮损失差 &lt; 0.0001）时，逐步减小 $ \alpha_i $、$ \alpha_f $，引入更多困难样本。</p><h5 id="构建批次子图">构建批次子图</h5><p>$G_b$ 是 $ G_t $的一个子图，针对每个训练批次（batch）生成，包含批次中的样本及其正负样本对，用于后续表征学习。过采样策略，从 $ G_t $中选择与批次样本相关的子图结构，保留类级别、模式级别和实例级别的关系，同时引入正样本和负样本以增强表征学习。</p><h4 id="关系图引导的表示学习">关系图引导的表示学习</h4><h5 id="簇感知表征平滑">簇感知表征平滑</h5><h6 id="图形平滑">图形平滑</h6><p>使用图卷积网络（GCN）$ \mathcal{G}(\cdot) $，基于子图 $ G_b $ 和正样本 $ \Omega_{posi} $，聚合同一类别图像的信息。<br>$$<br>F_g=\mathcal{G}(\hat{A},I_i,Ω_{posi})=softmax(\hat{A}⋅ReLU(\hat{A}⋅X⋅W^{(1)})⋅W^{(0)})<br>$$</p><h6 id="簇级特征平滑">簇级特征平滑</h6><p>将表征 $ F_g $ 与簇原型  $ w_{cu} $ 对齐，其中$w_{cu} $是类别 $ y_i $主导的最大簇 $c_j $的原型。<br>$$<br>F_u=α_u⊙F_g+β_u⊙w_{cu}<br>$$</p><h5 id="类级分布正则化">类级分布正则化</h5><h6 id="类级表征对齐">类级表征对齐</h6><p>表征 $ F_u$ 与类原型 $ p_{cu} $ 对齐，其中 $ p_{cu} $ 是类别 $ y_i $ 在所有主导簇中的表征聚合。<br>$$<br>F_a=α_a⊙F_u+β_a⊙p_{cu}<br>$$</p><h6 id="负样本约束">负样本约束</h6><p>构建负样本损失$\mathcal L_{neg}$，推远不同类别表征：<br>$$<br>\mathcal L_{neg} = \sum_{i=1}^{N} -\log \left( \mu_{i} \frac{\theta}{\sum_{q=1}^{m}|M_v(I_i) - M_v(\Omega_{nega}^q)|_2 + \theta} \right)<br>$$</p><h6 id="类间约束">类间约束</h6><p>构建类间分散损失$\mathcal L_{inter}$，进一步推远不同类别表征：<br>$$<br>\mathcal L_{inter} = \sum_{i,j} { i = j } |0| + { i \ne j } -\log \left( \mu\frac{\theta}{|F_v^i - F_v^j|_2 + \theta} \right)<br>$$</p><h6 id="分类器训练">分类器训练</h6><p>使用分类器 $ C(\cdot) $预测类别：<br>$$<br>F_a →P<br>$$<br>使用交叉熵损失 $\mathcal L_{ce}$优化：<br>$$<br>\mathcal L_{ce} = \frac{1}{N} \sum_{i} \mathcal L_i = -\frac{1}{N} \sum_{i}\sum_{c=1}^{C} y_{ic} \log(P_{ic})<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> CSRMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉表征 </tag>
            
            <tag> 论文精读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer</title>
      <link href="/2025/04/Transformer/"/>
      <url>/2025/04/Transformer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Attention Is All You Need</h1><p>个人理解 transformer 编码器是把人能理解的东西转化成计算机能理解的东西。对比与论文写作的这个过程来说，位置编码就是作者写这篇论文的顺序，反复打磨论文这个过程就对应着这个n个编码器，第一遍的初稿相当于第一个编码器，可能效果不尽人意。把人能理解的东西编码成论文。到读者来说就是解码的过程，每一次读论文就是一次解码的过程，你必须多次解码才能对这个论文理解的更加透彻，还要时刻注意mask操作，写作时要时刻注意读者理解到什么地步，读者的阅读是按顺序进行的。q就是你感兴趣的地方，k就是论文中的关键点。</p><p><strong>Transformer</strong> 是一种基于注意力机制（Attention Mechanism）的深度学习模型，摒弃了传统的循环神经网络（RNN）和卷积神经网络（CNN），完全依赖注意力机制处理序列数据。</p><p>RNN处理长序列时容易出现梯度消失或梯度爆炸的问题，健达来说就是就像一个记性不好的老人，处理长内容时，前面的内容记不住，后面又容易混淆。</p><p>CNN虽然在提取局部特征上表现出色，但对长距离依赖关系的捕捉能力欠佳，就好比只盯着眼前的局部风景，而忽略了远方的整体美景。</p><p>Transformer则巧妙地摒弃了RNN的顺序处理方式和CNN的局部处理局限，引入了自注意力机制，这就像是给大模型装上了一个“全局扫描雷达”，能够同时关注输入序列中的各个位置，极大地提升了对长序列的处理能力，完美解决了上述两个难题。</p><p>注意力机制通过注意力汇聚将<em>查询</em>（自主性提示）和<em>键</em>（非自主性提示）结合在一起，实现对<em>值</em>（感官输入）的<strong>选择倾向</strong>，这是与 CNN 等模型的关键区别。</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250425222936440.png" alt="transformer"></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250425223011527.png" alt="QKV" style="zoom:30%;" />]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文精读 </tag>
            
            <tag> transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于深度学习的图像分类</title>
      <link href="/2025/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
      <url>/2025/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="使用ResNet18预训练模型">使用ResNet18预训练模型</h2><p>由于笔记本性能太差，所以在服务器上运行的，显卡配置为4090。经大量实验判断，初始学习率为0.01最后效果较差，所以初始学习率应设为0.001。全部代码代码已上传到：<a href="https://github.com/wp-a/-CIFAR10-.git">https://github.com/wp-a/-CIFAR10-.git</a></p><h3 id="库函数导入">库函数导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, classification_report</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="数据集加载及增强操作">数据集加载及增强操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">transform_train = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">224</span>),<span class="comment">#图像从32x32放大到224x224是通过在原始像素之间插入新的像素点来实现的。插入的像素值是根据周围原始像素的值，通过不同的插值算法计算出来的，默认使用双线性插值。</span></span><br><span class="line">    transforms.RandomHorizontalFlip(), <span class="comment">#以 0.5 的概率水平随机翻转图像</span></span><br><span class="line">    transforms.RandomRotation(<span class="number">10</span>),  <span class="comment">#将图像随机旋转 -10 到 10 度之间的角度</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment">#将图像从 PIL 图像格式转换为 PyTorch 张量</span></span><br><span class="line">    transforms.Normalize((<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>), (<span class="number">0.2470</span>, <span class="number">0.2435</span>, <span class="number">0.2616</span>)) </span><br><span class="line">    <span class="comment">#使用为三个颜色通道中的每一个提供的平均和标准差来标准化图像的像素值(归一化)</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">transform_test = transforms.Compose([</span><br><span class="line">    transforms.Resize(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>), (<span class="number">0.2470</span>, <span class="number">0.2435</span>, <span class="number">0.2616</span>))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载CIFAR-10数据集</span></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(<span class="string">&quot;./data&quot;</span>, download=<span class="literal">True</span>, transform=transform_train)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(<span class="string">&quot;./data&quot;</span>, download=<span class="literal">True</span>, train=<span class="literal">False</span>, transform=transform_test)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span>  </span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_set, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(test_set, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回数字对应的类名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output_label</span>(<span class="params">label</span>):</span><br><span class="line">    output_mapping = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;plane&quot;</span>, <span class="number">1</span>: <span class="string">&quot;car&quot;</span>, <span class="number">2</span>: <span class="string">&quot;bird&quot;</span>, <span class="number">3</span>: <span class="string">&quot;cat&quot;</span>, <span class="number">4</span>: <span class="string">&quot;deer&quot;</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">&quot;dog&quot;</span>, <span class="number">6</span>: <span class="string">&quot;frog&quot;</span>, <span class="number">7</span>: <span class="string">&quot;horse&quot;</span>, <span class="number">8</span>: <span class="string">&quot;ship&quot;</span>, <span class="number">9</span>: <span class="string">&quot;truck&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">input</span> = (label.item() <span class="keyword">if</span> <span class="built_in">type</span>(label) == torch.Tensor <span class="keyword">else</span> label)</span><br><span class="line">    <span class="keyword">return</span> output_mapping[<span class="built_in">input</span>]</span><br></pre></td></tr></table></figure><h3 id="加载预训练模型">加载预训练模型</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_resnet18</span>(<span class="params">pretrained=<span class="literal">True</span></span>):</span><br><span class="line">    model = torchvision.models.resnet18(pretrained=pretrained)</span><br><span class="line">    model.fc = nn.Linear(<span class="number">512</span>, <span class="number">10</span>)  <span class="comment"># 修改最后一层以适应CIFAR10的10个类别</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">model = get_resnet18()</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><h3 id="模型训练超参数设置">模型训练超参数设置</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义损失函数，初始学习率，优化器</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment">#学习率调节器，前期需要较大步长来快速收敛，后期如还用较大步长可能会在极小值周围震荡，所以后期学习率逐步衰减。可以提高训练效率和性能。Adam负责在参数层面进行自适应的学习率调整，以加快收敛。学习率调度器负责在训练过程的宏观层面调整全局学习率，以提高模型的最终性能和泛化能力。二者不会产生冲突。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp_lr_scheduler</span>(<span class="params">optimizer, epoch, init_lr=<span class="number">0.001</span>, lr_decay_epoch=<span class="number">2</span></span>):</span><br><span class="line">    lr = init_lr * (<span class="number">0.1</span> ** (epoch // lr_decay_epoch))</span><br><span class="line">    <span class="keyword">if</span> epoch % lr_decay_epoch == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;LR is set to <span class="subst">&#123;lr&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">&#x27;lr&#x27;</span>] = lr</span><br><span class="line">    <span class="keyword">return</span> optimizer</span><br></pre></td></tr></table></figure><h3 id="模型训练">模型训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">6</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">loss_list = []</span><br><span class="line">iteration_list = []</span><br><span class="line">accuracy_list = []</span><br><span class="line">predictions_list = []</span><br><span class="line">labels_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    model.train() </span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    optimizer = exp_lr_scheduler(optimizer, epoch, init_lr=learning_rate, lr_decay_epoch=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        images, labels = images.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Step [<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader)&#125;</span>], Loss: <span class="subst">&#123;loss.item():<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            model.<span class="built_in">eval</span>()  </span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            correct = <span class="number">0</span></span><br><span class="line">            test_predictions = []</span><br><span class="line">            test_labels = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">                    images, labels = images.to(device), labels.to(device)</span><br><span class="line">                    test_labels.extend(labels.cpu().numpy())</span><br><span class="line"></span><br><span class="line">                    outputs = model(images)</span><br><span class="line">                    _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">                    test_predictions.extend(predicted.cpu().numpy())</span><br><span class="line"></span><br><span class="line">                    total += labels.size(<span class="number">0</span>)</span><br><span class="line">                    correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test set: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            loss_list.append(loss.item())</span><br><span class="line">            iteration_list.append(count)</span><br><span class="line">            accuracy_list.append(accuracy)</span><br><span class="line"></span><br><span class="line">            predictions_list.append(test_predictions)</span><br><span class="line">            labels_list.append(test_labels)</span><br><span class="line"></span><br><span class="line">            model.train()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="实验结果保存">实验结果保存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;resnet18_cifar10.pth&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Model saved to resnet18_cifar10.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(iteration_list, loss_list)</span><br><span class="line">plt.xlabel(<span class="string">&quot;No. of Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Iterations vs Loss&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;loss_curve.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(iteration_list, accuracy_list)</span><br><span class="line">plt.xlabel(<span class="string">&quot;No. of Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Iterations vs Accuracy&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;accuracy_curve.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">class_correct = [<span class="number">0.</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">total_correct = [<span class="number">0.</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">        images, labels = images.to(device), labels.to(device)</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(labels.size(<span class="number">0</span>)):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            total_correct[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accuracy of <span class="subst">&#123;classes[i]&#125;</span>: <span class="subst">&#123;<span class="number">100</span> * class_correct[i] / total_correct[i]:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">flat_predictions = <span class="built_in">list</span>(chain.from_iterable(predictions_list))</span><br><span class="line">flat_labels = <span class="built_in">list</span>(chain.from_iterable(labels_list))</span><br><span class="line"></span><br><span class="line">cm = confusion_matrix(flat_labels, flat_predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cm)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Classification report for ResNet on CIFAR-10:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classification_report(flat_labels, flat_predictions, target_names=classes))</span><br></pre></td></tr></table></figure><h3 id="实验结果分析">实验结果分析</h3><h4 id="lr分析">lr分析</h4><p>由实验结果可得lr=0.01时，效果较差，所以直接设置初始学习率为0.001可以更节省时间，提高效率。当学习率为1e-6时，发现准确率更新较小，所以准确率最小设置为1e-6。即学习率梯度为1e-3,1e-4,1e-5,1e-6，可以有较好的效果。即令epoch / lr_decay_epoch = 3或4 都可以，具体以epoch大小为准。</p><h5 id="lr-0-01">lr=0.01</h5><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415232217886.png" style="zoom:50%;" /><h5 id="lr-0-001">lr=0.001</h5><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415233045935.png" style="zoom:50%;" /><h5 id="lr-1e6">lr=1e6</h5><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415232556823.png" style="zoom:50%;" /><h4 id="batchsize分析">batchsize分析</h4><h5 id="Batchsize：64-epoch：6-lr-decay-epoch：2-初始学习率为0-001-94-46">Batchsize：64    epoch：6      lr_decay_epoch：2      初始学习率为0.001       94.46%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415220614773.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415220725745.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415205718074.png" style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415231949009.png" style="zoom:50%;" /><h5 id="Batchsize：128-epoch：12-lr-decay-epoch：3-初始学习率为0-001-95-23">Batchsize：128       epoch：12      lr_decay_epoch：3        初始学习率为0.001     95.23%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415234407813.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415234416059.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415234515857.png"  style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250415234548312.png"  style="zoom:50%;" /><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为0-01-85-87">Batchsize：128    epoch：20      lr_decay_epoch：5       初始学习率为0.01        85.87%</h5><p>和分析的一致，对比下面实验，控制变量，只有初始学习率改变，精度提升10%左右。</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011056469.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011103696.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011422605.png"  style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011431888.png"  style="zoom:50%;" /><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为0-001-95-44">Batchsize：128    epoch：20      lr_decay_epoch：5       初始学习率为0.001        95.44%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011705314.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011712657.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011728662.png"  style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416011735321.png"  style="zoom:50%;" /><h5 id="Batchsize：64-epoch：20-lr-decay-epoch：5-初始学习率为0-001-95-66">Batchsize：64      epoch：20      lr_decay_epoch：5       初始学习率为0.001        95.66%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111941885.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111952429.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416112318297.png"  style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416112327065.png"  style="zoom:50%;" /><h2 id="使用LeNet网络">使用LeNet网络</h2><p>与Resnet相比换了一个网络和改了数据加载模块，其他没啥变化。</p><h3 id="库函数导入-2">库函数导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, classification_report</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="数据集加载及增强操作-2">数据集加载及增强操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">        [transforms.RandomHorizontalFlip(),</span><br><span class="line">         transforms.RandomCrop(<span class="number">32</span>, padding=<span class="number">4</span>),</span><br><span class="line">         transforms.ToTensor(),</span><br><span class="line">         transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                            download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">train_loader = torch.utils.data.DataLoader(trainset, batch_size=<span class="number">32</span>,</span><br><span class="line">                                              shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                           download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">test_loader = torch.utils.data.DataLoader(testset, batch_size=<span class="number">32</span>,</span><br><span class="line">                                             shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output_label</span>(<span class="params">label</span>):</span><br><span class="line">    output_mapping = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;plane&quot;</span>, <span class="number">1</span>: <span class="string">&quot;car&quot;</span>, <span class="number">2</span>: <span class="string">&quot;bird&quot;</span>, <span class="number">3</span>: <span class="string">&quot;cat&quot;</span>, <span class="number">4</span>: <span class="string">&quot;deer&quot;</span>,</span><br><span class="line">        <span class="number">5</span>: <span class="string">&quot;dog&quot;</span>, <span class="number">6</span>: <span class="string">&quot;frog&quot;</span>, <span class="number">7</span>: <span class="string">&quot;horse&quot;</span>, <span class="number">8</span>: <span class="string">&quot;ship&quot;</span>, <span class="number">9</span>: <span class="string">&quot;truck&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">input</span> = (label.item() <span class="keyword">if</span> <span class="built_in">type</span>(label) == torch.Tensor <span class="keyword">else</span> label)</span><br><span class="line">    <span class="keyword">return</span> output_mapping[<span class="built_in">input</span>]</span><br></pre></td></tr></table></figure><h3 id="LeNet模型">LeNet模型</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(C1, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.c1 = nn.Sequential(OrderedDict([</span><br><span class="line">            (<span class="string">&#x27;conv1&#x27;</span>, nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>))),</span><br><span class="line">            (<span class="string">&#x27;relu1&#x27;</span>, nn.ReLU()),</span><br><span class="line">            (<span class="string">&#x27;pool1&#x27;</span>, nn.MaxPool2d(kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=<span class="number">2</span>))</span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.c1(img)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(C3, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.c3 = nn.Sequential(OrderedDict([</span><br><span class="line">            (<span class="string">&#x27;conv3&#x27;</span>, nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>))),</span><br><span class="line">            (<span class="string">&#x27;relu3&#x27;</span>, nn.ReLU()),</span><br><span class="line">            (<span class="string">&#x27;pool3&#x27;</span>, nn.MaxPool2d(kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=<span class="number">2</span>))</span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.c3(img)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F4</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(F4, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.f4 = nn.Sequential(OrderedDict([</span><br><span class="line">            (<span class="string">&#x27;fc4&#x27;</span>, nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)),</span><br><span class="line">            (<span class="string">&#x27;relu4&#x27;</span>, nn.ReLU())</span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.f4(img)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F5</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(F5, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.f5 = nn.Sequential(OrderedDict([</span><br><span class="line">            (<span class="string">&#x27;fc5&#x27;</span>, nn.Linear(<span class="number">120</span>, <span class="number">84</span>)),</span><br><span class="line">            (<span class="string">&#x27;relu5&#x27;</span>, nn.ReLU())</span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.f5(img)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F6</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(F6, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.f6 = nn.Sequential(OrderedDict([</span><br><span class="line">            (<span class="string">&#x27;fc6&#x27;</span>, nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br><span class="line">        ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.f6(img)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet5</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet5, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.c1 = C1()</span><br><span class="line">        <span class="variable language_">self</span>.c3 = C3()</span><br><span class="line">        <span class="variable language_">self</span>.f4 = F4()</span><br><span class="line">        <span class="variable language_">self</span>.f5 = F5()</span><br><span class="line">        <span class="variable language_">self</span>.f6 = F6()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        output = <span class="variable language_">self</span>.c1(img)</span><br><span class="line">        output = <span class="variable language_">self</span>.c3(output)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        output = <span class="variable language_">self</span>.f4(output)</span><br><span class="line">        output = <span class="variable language_">self</span>.f5(output)</span><br><span class="line">        output = <span class="variable language_">self</span>.f6(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h3 id="模型训练超参数设置-2">模型训练超参数设置</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义损失函数，初始学习率，优化器</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment">#学习率调节器，前期需要较大步长来快速收敛，后期如还用较大步长可能会在极小值周围震荡，所以后期学习率逐步衰减。可以提高训练效率和性能。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp_lr_scheduler</span>(<span class="params">optimizer, epoch, init_lr=<span class="number">0.001</span>, lr_decay_epoch=<span class="number">2</span></span>):</span><br><span class="line">    lr = init_lr * (<span class="number">0.1</span> ** (epoch // lr_decay_epoch))</span><br><span class="line">    <span class="keyword">if</span> epoch % lr_decay_epoch == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;LR is set to <span class="subst">&#123;lr&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">&#x27;lr&#x27;</span>] = lr</span><br><span class="line">    <span class="keyword">return</span> optimizer</span><br></pre></td></tr></table></figure><h3 id="模型训练-2">模型训练</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">20</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">loss_list = []</span><br><span class="line">iteration_list = []</span><br><span class="line">accuracy_list = []</span><br><span class="line">predictions_list = []</span><br><span class="line">labels_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    model.train() </span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    optimizer = exp_lr_scheduler(optimizer, epoch, init_lr=learning_rate, lr_decay_epoch=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (images, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        images, labels = images.to(device), labels.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = model(images)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Step [<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader)&#125;</span>], Loss: <span class="subst">&#123;loss.item():<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            model.<span class="built_in">eval</span>() </span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            correct = <span class="number">0</span></span><br><span class="line">            test_predictions = []</span><br><span class="line">            test_labels = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">                    images, labels = images.to(device), labels.to(device)</span><br><span class="line">                    test_labels.extend(labels.cpu().numpy())</span><br><span class="line"></span><br><span class="line">                    outputs = model(images)</span><br><span class="line">                    _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">                    test_predictions.extend(predicted.cpu().numpy())</span><br><span class="line"></span><br><span class="line">                    total += labels.size(<span class="number">0</span>)</span><br><span class="line">                    correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test set: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            loss_list.append(loss.item())</span><br><span class="line">            iteration_list.append(count)</span><br><span class="line">            accuracy_list.append(accuracy)</span><br><span class="line"></span><br><span class="line">            predictions_list.append(test_predictions)</span><br><span class="line">            labels_list.append(test_labels)</span><br><span class="line"></span><br><span class="line">            model.train()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="实验结果保存-2">实验结果保存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;lenet5_cifar10.pth&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Model saved to lenet5_cifar10.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(iteration_list, loss_list)</span><br><span class="line">plt.xlabel(<span class="string">&quot;No. of Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Iterations vs Loss&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;loss_curve.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(iteration_list, accuracy_list)</span><br><span class="line">plt.xlabel(<span class="string">&quot;No. of Iteration&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Accuracy&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Iterations vs Accuracy&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;accuracy_curve.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">class_correct = [<span class="number">0.</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">total_correct = [<span class="number">0.</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> test_loader:</span><br><span class="line">        images, labels = images.to(device), labels.to(device)</span><br><span class="line">        outputs = model(images)</span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(labels.size(<span class="number">0</span>)):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            total_correct[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accuracy of <span class="subst">&#123;classes[i]&#125;</span>: <span class="subst">&#123;<span class="number">100</span> * class_correct[i] / total_correct[i]:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line">flat_predictions = <span class="built_in">list</span>(chain.from_iterable(predictions_list))</span><br><span class="line">flat_labels = <span class="built_in">list</span>(chain.from_iterable(labels_list))</span><br><span class="line"></span><br><span class="line">cm = confusion_matrix(flat_labels, flat_predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cm)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Classification report for LeNet on CIFAR-10:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(classification_report(flat_labels, flat_predictions, target_names=classes))</span><br></pre></td></tr></table></figure><h3 id="实验结果分析-2">实验结果分析</h3><h4 id="使用图像增强操作">使用图像增强操作</h4><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为-0-001-60-56">Batchsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001       60.56%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143045031.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143053524.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143111341.png" style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143119004.png" style="zoom:50%;" /><h4 id="未使用图像增强操作">未使用图像增强操作</h4><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为-0-001-62-66">Batchsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001       62.66%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417100137609.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417100147883.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417100211736.png" style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417100219120.png" style="zoom:50%;" /><h2 id="使用FashionNet">使用FashionNet</h2><p>代码详见github</p><h3 id="图像增强操作训练结果分析">图像增强操作训练结果分析</h3><h4 id="使用图像增强操作-2">使用图像增强操作</h4><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为-0-001-71-51">Batchsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001        71.51%</h5><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417094047006.png" style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250417094113225.png" style="zoom:50%;" /><h4 id="未使用图像增强操作-2">未使用图像增强操作</h4><h5 id="Batchsize：128-epoch：30-lr-decay-epoch：6-初始学习率为-0-01-71-69">Batchsize：128      epoch：30      lr_decay_epoch：6     初始学习率为 0.01        71.69%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416003738154.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416003746404.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416004553116.png"  style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416004618803.png" style="zoom:50%;" /><h5 id="Batchsize：128-epoch：20-lr-decay-epoch：5-初始学习率为-0-001-74-25">Batchsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001        74.25%</h5><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416124752133.png" alt=""></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416124817538.png" alt=""></p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416125051704.png" style="zoom:50%;" /><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416125058999.png" style="zoom:50%;" /><h2 id="Gradcam实现图像特征可视化">Gradcam实现图像特征可视化</h2><p>Grad-CAM 的目标层均为最后一个卷积层</p><h3 id="Resnet效果图">Resnet效果图</h3><p>参数配置    Batch_size：64    epoch：20      lr_decay_epoch：5     lr：0.001      95.66%</p><p>图片来自谷歌。</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111154160.jpg" style="zoom: 99%;" />  <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111246144.png" style="zoom: 50%;" /></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111555414.jpg" alt="">      <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111606162.png" style="zoom:50%;" /></p><h3 id="FashionNet效果图">FashionNet效果图</h3><p>参数配置      Bachsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001        74.25%</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111154160.jpg" style="zoom: 99%;" />  <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416130110520.png"  style="zoom:50%;" /></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111555414.jpg" alt="">      <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416130415531.png"  style="zoom:50%;" /></p><h3 id="LeNet效果图">LeNet效果图</h3><p>参数配置      Bachsize：128      epoch：20      lr_decay_epoch：5     初始学习率为 0.001       60.56%</p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111154160.jpg" style="zoom: 99%;" />  <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143505157.png"  style="zoom:50%;" /></p><p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416111555414.jpg" alt="">      <img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250416143631428.png"  style="zoom:50%;" /></p><h2 id="总结">总结</h2><h3 id="数据集在不同模型上的准确率">数据集在不同模型上的准确率</h3><table><thead><tr><th>模型</th><th>准确率</th></tr></thead><tbody><tr><td>ResNet</td><td>95.66%</td></tr><tr><td>LeNet</td><td>62.66%</td></tr><tr><td>FashionNet</td><td>74.25%</td></tr></tbody></table><h3 id="LeNet对数据集进行图像增强操作的影响">LeNet对数据集进行图像增强操作的影响</h3><p>分析：由于模型过于简单，本来就会出现欠拟合现象，继续进行图像增强操作后会导致模型更加欠拟合。所以出现三个模型精度差距较大，主要是因为模型复杂度的差距。虽然是欠拟合，但是继续增加epoch也并不会提高精度，因为模型对数据已经学到了尽可能多的知识。</p><table><thead><tr><th>未归一化</th><th>归一化</th><th>图像增强操作</th><th>大量图像增强操作</th></tr></thead><tbody><tr><td>58.75%</td><td>62.66%</td><td>60.56%</td><td>56.78%</td></tr></tbody></table><h3 id="神经网络参数对模型准确率的影响">神经网络参数对模型准确率的影响</h3><p>batch_size：64或128并无太大影响。</p><p>初始学习率：由实验结果可得lr=0.01时，效果较差，三个网络都使用了0.01进行测试得出的结果，有的实验结果没贴图。所以直接设置初始学习率为0.001可以更节省时间，提高效率。当学习率为1e-6时，发现准确率更新较小，所以准确率最小设置为1e-6。即学习率梯度为1e-3,1e-4,1e-5,1e-6，可以有较好的效果。</p><p>lr_decay_epoch和epoch：即学习率梯度为1e-3,1e-4,1e-5,1e-6，可以有较好的效果。即令epoch / lr_decay_epoch = 3或4 都可以，具体以epoch大小为准。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 图像分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 图像分类 </tag>
            
            <tag> Resnet </tag>
            
            <tag> Lenet </tag>
            
            <tag> CIFAR10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--动态规划</title>
      <link href="/2025/03/14day/"/>
      <url>/2025/03/14day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态规划">动态规划</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><h3 id="斐波那契数">斐波那契数</h3><p>题目链接：<a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></p><p>前几天做过一个斐波那契用递归超时，动态规划感觉就是递归加剪枝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯">爬楼梯</h3><p>题目链接：<a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><p>按照题意，要上楼梯的话，第一步只有两种上法，要么走一级台阶要么走两级台阶，走了一级台阶之后，等于是还要上一个n-1级台阶的楼梯，同理，走了两级台阶的话就等于是还要上一个n-2级台阶的楼梯，以此类推这样动态规划的思想就体现出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用最小花费爬楼梯">使用最小花费爬楼梯</h3><p>题目链接：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size()<span class="number">+1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cost.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不同路径">不同路径</h3><p>题目链接：<a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">f</span><span class="params">(m + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i][j + <span class="number">1</span>] + f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="比特位计数">比特位计数</h3><p>题目链接：<a href="https://leetcode.cn/problems/w3tCBm/">LCR 003. 比特位计数</a></p><h4 id="除以2">除以2</h4><p>如果 <code>i</code> 是偶数，那么 <code>i</code> 的二进制表示中 1 的个数与 <code>i / 2</code> 的二进制表示中 1 的个数相同。</p><p>如果 <code>i</code> 是奇数，那么 <code>i</code> 的二进制表示中 1 的个数比 <code>i / 2</code> 的二进制表示中 1 的个数多 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i] = ans[i / <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = ans[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="位运算">位运算</h4><p>进行按位与运算 <code>i &amp; (i - 1)</code> 后，从最右边的 1 开始的所有位都会变成 0，而其左边的位保持不变。因此，<code>i &amp; (i - 1)</code> 的结果就是将 <code>i</code> 最右边的 1 去掉后得到的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans[i] = ans[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--排序算法</title>
      <link href="/2025/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>排序算法详解</h1><p>排序算法是计算机科学中最基础也是最重要的算法之一。本文将详细介绍几种常见的排序算法，包括它们的实现原理、时间复杂度和适用场景。本文所有代码示例使用 C++ 实现，需要包含以下头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h2 id="1-冒泡排序-Bubble-Sort">1. 冒泡排序 (Bubble Sort)</h2><p>冒泡排序是最简单的排序算法之一，它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><h3 id="实现原理">实现原理</h3><ul><li>时间复杂度：O(n²)</li><li>空间复杂度：O(1)</li><li>稳定性：稳定</li></ul><h3 id="实现代码">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> swapped;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 每一轮比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 相邻元素比较并交换</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j<span class="number">+1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j<span class="number">+1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有发生交换，说明数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序-Selection-Sort">2. 选择排序 (Selection Sort)</h2><p>选择排序的工作原理是每次从待排序的数据中选出最小（或最大）的元素，存放在序列的起始位置。</p><h3 id="实现原理-2">实现原理</h3><ul><li>时间复杂度：O(n²)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ul><h3 id="实现代码-2">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="comment">// 在未排序部分找最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将找到的最小值放到已排序序列的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(min_idx != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[min_idx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序-Insertion-Sort">3. 插入排序 (Insertion Sort)</h2><p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="实现原理-3">实现原理</h3><ul><li>时间复杂度：O(n²)</li><li>空间复杂度：O(1)</li><li>稳定性：稳定</li></ul><h3 id="实现代码-3">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将大于key的元素都向后移动</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j<span class="number">+1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j<span class="number">+1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-快速排序-Quick-Sort">4. 快速排序 (Quick Sort)</h2><p>快速排序是一种分治算法，它通过选择一个&quot;基准&quot;元素，将数组分成两个子数组，小于基准的元素放在左边，大于基准的元素放在右边。</p><h3 id="实现原理-4">实现原理</h3><ul><li>时间复杂度：平均 O(nlogn)，最坏 O(n²)</li><li>空间复杂度：O(logn)</li><li>稳定性：不稳定</li></ul><h3 id="实现代码-4">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];    <span class="comment">// 选择最右边的元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;          <span class="comment">// 小于基准的元素的最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素小于基准，则将其交换到前面</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 获取分区点</span></span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">        <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装函数，方便调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-归并排序-Merge-Sort">5. 归并排序 (Merge Sort)</h2><p>归并排序是一种分治算法，它将数组分成两半，递归地排序两半，然后将它们合并起来。</p><h3 id="实现原理-5">实现原理</h3><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)</li><li>稳定性：稳定</li></ul><h3 id="实现代码-5">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right - left + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将临时数组复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装函数，方便调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-堆排序-Heap-Sort">6. 堆排序 (Heap Sort)</h2><p>堆排序是利用堆这种数据结构所设计的一种排序算法。它通过构建最大堆或最小堆来进行排序。</p><h3 id="实现原理-6">实现原理</h3><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ul><h3 id="实现代码-6">实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于根节点</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果右子节点大于最大值</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最大值不是根节点</span></span><br><span class="line">    <span class="keyword">if</span>(largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个个从堆顶取出元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序算法的比较">排序算法的比较</h2><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n²)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><h2 id="如何选择排序算法？">如何选择排序算法？</h2><ol><li>数据量小（n &lt; 50）：插入排序</li><li>数据量大：<ul><li>要求稳定：归并排序</li><li>不要求稳定：快速排序</li></ul></li><li>内存空间有限：堆排序</li><li>数据基本有序：插入排序</li><li>数据量特别大且有重复：计数排序/基数排序</li></ol><h2 id="总结">总结</h2><p>每种排序算法都有其特点和适用场景。在实际应用中，我们需要根据具体情况（数据规模、稳定性要求、空间限制等）来选择合适的排序算法。大多数编程语言的标准库中的排序实现都是一种改进的快速排序，它能够很好地适应各种情况。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 选择排序 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--图论</title>
      <link href="/2025/03/13day/"/>
      <url>/2025/03/13day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图论">图论</h2><h3 id="图的存储方式">图的存储方式</h3><h4 id="邻接矩阵">邻接矩阵</h4><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从<strong>节点的角度</strong>来表示图，有多少节点就申请多大的二维数组。</p><p>有n 个节点，因为节点标号是从1开始的，为了节点标号和下标对齐，申请 n + 1 * n + 1  这么大的二维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t</span><br><span class="line">    <span class="comment">// 使用邻接矩阵 ，1 表示 节点s 指向 节点t</span></span><br><span class="line">    graph[s][t] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表">邻接表</h4><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造相对邻接矩阵难理解一些。</p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240223103713.png" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表，list为C++里的链表</span></span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">    graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索三部曲">深度优先搜索三部曲</h3><ol><li>确认递归函数，参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 0节点到终点的路径</span></span><br><span class="line"><span class="comment">// x：目前遍历的节点</span></span><br><span class="line"><span class="comment">// graph：存当前的图</span></span><br><span class="line"><span class="comment">// n：终点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br></pre></td></tr></table></figure><ol start="2"><li>确认终止条件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line"><span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>处理目前搜索节点出发的路径</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">    <span class="keyword">if</span> (graph[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>打印结果</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 这里指打印到倒数第二个</span></span><br><span class="line">        cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl; <span class="comment">// 这里再打印倒数第一个，控制最后一个元素后面没有空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：所有可能的路径">例题：所有可能的路径</h3><p>题目链接：<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></p><h4 id="邻接矩阵写法">邻接矩阵写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (graph[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表写法">邻接表写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : graph[x]) &#123; <span class="comment">// 找到 x指向的节点</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--图论</title>
      <link href="/2025/03/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2025/03/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础知识–图论">基础知识–图论</h2><p>图论是数学的一个分支，<strong>以图为研究对象</strong>。  图论中的“图”是一种抽象的数学结构，由<strong>顶点</strong>（点）和连接顶点的<strong>边</strong>（线）构成，用于描述事物之间特定的<strong>关系</strong>。</p><ul><li><strong>核心思想</strong>:  用点代表事物，用连接两点的线表示事物之间的关系。</li></ul><h3 id="图的基本概念">图的基本概念</h3><ol><li><p><strong>图 (Graph)</strong></p><p>一个图 G 由两个基本集合构成：</p><ul><li><strong>顶点集 (Vertex Set) V(G):</strong>  图中所有顶点的集合。 顶点通常用点、小圆圈或标签表示。</li><li><strong>边集 (Edge Set) E(G):</strong>  图中所有边的集合。 边连接一对顶点，表示顶点之间的关系。 边通常用线段、曲线或箭头表示。</li></ul><p>我们可以用数学符号表示一个图：  <strong>G = (V, E)</strong></p></li><li><p><strong>顶点 (Vertex / Node / Point)</strong></p><ul><li>图的基本组成部分，代表<strong>研究对象</strong>或<strong>实体</strong>。</li><li><strong>示例</strong>:<ul><li>在社交网络中，顶点可以代表 <strong>人</strong>。</li><li>在交通网络中，顶点可以代表 <strong>城市</strong>。</li><li>在电路图中，顶点可以代表 <strong>电子元件</strong>。</li></ul></li></ul></li><li><p><strong>边 (Edge / Arc / Line)</strong></p><ul><li>连接两个顶点的线，表示顶点之间存在的<strong>关系</strong>。</li><li><strong>示例</strong>:<ul><li>在社交网络中，边可以表示两个人之间的 <strong>朋友关系</strong>。</li><li>在交通网络中，边可以表示两个城市之间的 <strong>道路</strong>。</li><li>在电路图中，边可以代表 <strong>导线</strong>。</li></ul></li></ul></li><li><p><strong>关联 (Incidence)</strong></p><ul><li>如果一条边 <em>e</em> 连接了顶点 <em>u</em> 和 <em>v</em>，则称边 <em>e</em> 与顶点 <em>u</em> 和 <em>v</em> <strong>关联</strong>。</li><li>简单来说，就是边“连接到”哪些顶点。</li></ul></li><li><p><strong>邻接 (Adjacency)</strong></p><ul><li><strong>顶点邻接</strong>: 如果两个顶点 <em>u</em> 和 <em>v</em> 被一条边直接连接，则称顶点 <em>u</em> 和 <em>v</em> 是<strong>邻接的</strong>。</li><li><strong>边邻接</strong>: 如果两条边 <strong>共享</strong> 一个公共顶点，则称这两条边是<strong>邻接的</strong>。</li></ul></li><li><p><strong>度 (Degree)</strong></p><ul><li><p>一个顶点的<strong>度</strong>是指与该顶点<strong>关联的边</strong>的数量。  度反映了顶点与其他顶点的连接数量。</p></li><li><p><strong>有向图的度</strong>:  对于有向图，度分为两种：</p><ul><li><strong>入度 (In-degree)</strong>:  指向该顶点的边的数量 (有多少边进入该顶点)。</li><li><strong>出度 (Out-degree)</strong>:  从该顶点出发的边的数量 (有多少边从该顶点出发)。</li></ul></li></ul></li><li><p><strong>路径 (Path)</strong></p><ul><li>图中从一个顶点到另一个顶点，<strong>依次经过</strong>的顶点和边的序列。</li><li>路径中<strong>通常不重复</strong>经过顶点，除非是环路。</li></ul></li><li><p><strong>环路/回路 (Cycle)</strong></p><ul><li>一种特殊的路径，<strong>起点和终点是同一个顶点</strong>。</li><li>环路表示从一个点出发，可以回到原点的路径。</li></ul></li><li><p><strong>简单路径 (Simple Path)</strong></p><ul><li>路径中<strong>所有顶点都不同</strong>的路径。</li><li>简单路径避免了在路径中重复访问同一个顶点。</li></ul></li><li><p><strong>简单环路/简单回路 (Simple Cycle)</strong></p><ul><li>环路中，除了起点和终点相同外，<strong>所有其他顶点都不同</strong>的环路。</li><li>简单环路是最基本的环路形式，避免了在环路中重复访问除起点/终点之外的顶点。</li></ul></li></ol><h3 id="图的类型">图的类型</h3><h4 id="有向图-vs-无向图"><strong>有向图 vs 无向图</strong></h4><ul><li><p><strong>无向图</strong>: 边 <strong>没有方向</strong>，表示连接的两个顶点是<strong>互通的</strong>。 通常用  <strong>(v, w)</strong>  表示顶点 <em>v</em> 和 <em>w</em> 之间的无向边。</p></li><li><p><strong>有向图</strong>: 边 <strong>有方向</strong>，表示连接的两个顶点之间是<strong>单向</strong>关系。  通常用  <strong>&lt;v, w&gt;</strong>  表示从顶点 <em>v</em> 指向顶点 <em>w</em> 的有向边。</p></li></ul><h4 id="有权图-vs-无权图"><strong>有权图 vs 无权图</strong></h4><ul><li><p><strong>有权图</strong>: 图的每条边都被赋予一个 <strong>权重 (weight)</strong>，通常是一个数字。 权重可以代表 <strong>距离、成本、时间</strong> 等实际含义。</p></li><li><p><strong>无权图</strong>: 图的边 <strong>没有权重</strong>。 可以理解为所有边的权重都相同（例如权重为 1）。</p></li></ul><h4 id="连通图-vs-非连通图"><strong>连通图 vs 非连通图</strong></h4><ul><li><p><strong>连通图 (针对无向图)</strong>:  图中 <strong>任意两个顶点之间都存在路径</strong>。  这意味着从图中任何一个顶点出发，都可以到达其他任何顶点。</p></li><li><p><strong>非连通图 (针对无向图)</strong>:  图中 <strong>至少存在一对顶点之间没有路径</strong>。  非连通图由多个互相独立的“部分”组成。</p></li><li><p><strong>连通分量 (Connected Component)</strong>:  非连通图可以被划分成多个 <strong>连通的子图</strong>，每个这样的连通子图被称为一个 <strong>连通分量</strong>。 连通图自身只有一个连通分量，就是它本身。</p></li></ul><h4 id="强连通-vs-单连通"><strong>强连通 vs 单连通</strong></h4><ul><li><strong>强连通 (Strongly Connected)</strong>:  <strong>有向图</strong> 中，<strong>任意两个顶点之间都存在互相可达的路径</strong>。  即从顶点 <em>u</em> 可以到达 <em>v</em>，同时从顶点 <em>v</em> 也可以到达 <em>u</em>。</li><li><strong>单连通 (Unilaterally Connected)</strong>: <strong>有向图</strong> 中，<strong>任意两个顶点之间都存在至少一个方向可达的路径</strong> （无需互相可达）。  即对于任意两个顶点 <em>u</em> 和 <em>v</em>，要么从 <em>u</em> 可以到达 <em>v</em>，要么从 <em>v</em> 可以到达 <em>u</em>，或者两者都成立。</li></ul><h3 id="图的表示方法">图的表示方法</h3><h4 id="邻接矩阵表示法">邻接矩阵表示法</h4><p>邻接矩阵是一个二维数组，用于表示顶点之间的连接关系：</p><ul><li>对于无权图，矩阵元素 A[i][j] = 1 表示顶点 i 和 j 之间有边相连，A[i][j]= 0 表示没有边相连</li><li>对于有权图，矩阵元素 A[i][j]表示顶点 i 和 j 之间边的权值，通常用一个特殊值（如∞或0）表示不存在的边</li></ul><p><strong>优点</strong>：</p><ul><li>实现简单，便于理解</li><li>查询两点间是否有边的时间复杂度为 O(1)</li><li>适合表示稠密图</li></ul><p><strong>缺点</strong>：</p><ul><li>空间复杂度为 O(V²)，其中 V 是顶点数，对于稀疏图会浪费大量空间</li><li>添加/删除顶点的操作较为复杂</li></ul><h4 id="邻接表表示法">邻接表表示法</h4><p>邻接表使用一个数组，数组的每个元素是一个链表，用于存储与该顶点相邻的所有顶点：</p><ul><li>数组索引 i 对应顶点 i</li><li>链表中存储的是与顶点 i 相邻的所有顶点</li></ul><p><strong>优点</strong>：</p><ul><li>节省空间，特别适合稀疏图</li><li>容易找到给定顶点的所有邻接点</li><li>添加顶点操作简单</li></ul><p><strong>缺点</strong>：</p><ul><li>查询两点间是否有边的时间复杂度为 O(V)，不如邻接矩阵高效</li><li>对有向图求逆邻接表较困难</li></ul><h4 id="十字链表表示法">十字链表表示法</h4><p>十字链表是邻接表的改进版本，主要用于有向图：</p><ul><li>结合了邻接表和逆邻接表的特点</li><li>每个顶点有一个出边表和一个入边表</li><li>每条边用一个结点表示，同时出现在起点的出边表和终点的入边表中</li></ul><p><strong>优点</strong>：</p><ul><li>容易找到顶点的所有出边和入边</li><li>适合需要频繁查询入度和出度的应用场景</li></ul><h4 id="邻接多重表">邻接多重表</h4><p>邻接多重表主要用于无向图：</p><ul><li>每条边只存储一次</li><li>每个顶点有一个边表</li><li>每条边连接到与其关联的两个顶点的边表中</li></ul><p><strong>优点</strong>：</p><ul><li>便于删除和查找特定边</li><li>节省空间</li></ul><h4 id="边集数组表示法">边集数组表示法</h4><p>边集数组直接存储图中所有的边：</p><ul><li>使用一个一维数组存储所有顶点信息</li><li>使用另一个数组存储所有边的信息（包括起点、终点和权值）</li></ul><p><strong>优点</strong>：</p><ul><li>实现简单</li><li>适合只关注边的操作，如最小生成树的Kruskal算法</li><li>适合稀疏图</li></ul><p><strong>缺点</strong>：</p><ul><li>查找操作效率较低</li><li>不易找到与特定顶点相连的所有边</li></ul><p>选择哪种表示方法取决于图的特性（如稠密度）和需要执行的操作类型（如是否需要频繁查询、添加或删除顶点和边）。</p><h3 id="图的遍历方法">图的遍历方法</h3><h4 id="DFS-深度优先搜索">DFS(深度优先搜索)</h4><p>深度优先搜索沿着图的深度尽可能远地探索，直到不能再深入为止，然后回溯到前一个节点，继续探索其他路径。</p><h5 id="基本算法步骤">基本算法步骤</h5><ol><li>选择一个起始顶点，将其标记为已访问</li><li>对该顶点的每个未访问的邻接点，递归地应用DFS</li><li>如果当前顶点没有未访问的邻接点，则回溯</li></ol><h5 id="时间复杂度与空间复杂度">时间复杂度与空间复杂度</h5><ul><li>时间复杂度：O(V + E)</li><li>空间复杂度：O(V)</li></ul><h5 id="应用场景">应用场景</h5><ul><li>拓扑排序</li><li>寻找连通分量</li><li>判断图中是否有环</li><li>寻找路径（如迷宫问题）</li></ul><h4 id="BFS-广度优先搜索">BFS(广度优先搜索)</h4><p>广度优先搜索是一种按&quot;层次&quot;访问节点的方法，先访问起始顶点的所有邻接点，然后再访问这些邻接点的邻接点，以此类推。</p><h5 id="基本算法步骤-2">基本算法步骤</h5><ol><li>选择一个起始顶点，将其标记为已访问，并放入队列中</li><li>当队列不为空时，执行以下操作：<ul><li>取出队列中的第一个顶点u</li><li>访问顶点u</li><li>将u的所有未访问过的邻接点标记为已访问并加入队列</li></ul></li></ol><h5 id="时间复杂度与空间复杂度-2">时间复杂度与空间复杂度</h5><ul><li>时间复杂度：O(V + E)，其中V是顶点数，E是边数</li><li>空间复杂度：O(V)，用于存储访问状态和队列</li></ul><h5 id="应用场景-2">应用场景</h5><ul><li>寻找最短路径（无权图）</li><li>网络爬虫</li><li>社交网络中的关系距离（如&quot;六度分隔&quot;理论）</li><li>层次遍历</li></ul><h3 id="图的应用">图的应用</h3><h4 id="最小生成树算法">最小生成树算法</h4><p><code>无向图</code> G 的生成树是具有 G 的全部顶点，但<code>边数最少</code>的<code>连通子图</code>（连通子图并非连通分量）。一个图的生成树可能有多个。</p><h5 id="Kruskal算法">Kruskal算法</h5><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250308182616583.gif" style="zoom:50%;" /><ul><li><strong>思想</strong>：贪心策略，每次选择图中权值最小的边，加入生成树中（前提是不形成环）。</li><li>步骤：<ol><li>对所有边按照权值进行排序。</li><li>依次从小到大考虑每条边，如果当前边加入后不构成环，则加入生成树。</li><li>重复直到生成树中包含 n−1 条边。</li></ol></li><li><strong>特点</strong>：适合边比较少的稀疏图，利用并查集来判断是否形成环。</li></ul><h5 id="Prim算法">Prim算法</h5><ul><li><strong>思想</strong>：贪心策略，从一个起始顶点开始，每次选择与当前生成树相连的、权值最小的边，将新的顶点加入生成树。</li><li>步骤：<ol><li>从任一顶点开始，将其加入生成树。</li><li>找出所有与当前生成树相连的边，选择其中权值最小的边，将边的另一端顶点加入生成树。</li><li>重复直到所有顶点都被加入生成树。</li></ol></li><li><strong>特点</strong>：适合边较多的稠密图，通过优先队列（堆）优化可以达到较高效率。</li></ul><h4 id="最短路径算法">最短路径算法</h4><h5 id="Dijkstra算法">Dijkstra算法</h5><p>从起点开始，每次选择当前已知最短距离的顶点，然后更新与它相邻的顶点的距离。</p><p><strong>基本流程</strong></p><ol><li>初始化：源点距离设为0，其他顶点距离设为无穷大</li><li>每次选择未访问的距离最小的顶点，标记为已访问</li><li>更新该顶点的邻居顶点的距离</li><li>重复步骤2-3直到所有顶点被访问</li></ol><p><strong>算法复杂度</strong></p><ul><li>时间复杂度：O(V²)，其中V是顶点数。如果使用优先队列优化，可以降低到O((V+E)logV)，其中E是边数。</li><li>空间复杂度：O(V)</li></ul><p><strong>算法的局限性</strong></p><ol><li>迪杰斯特拉算法不能处理负权边</li><li>在稠密图中，性能可能不如其他算法（如贝尔曼-福特算法）</li></ol><p><strong>应用场景</strong></p><ul><li>导航系统</li><li>网络路由协议</li><li>社交网络分析</li><li>电信网络规划</li></ul><h5 id="Floyd-Warshall算法">Floyd-Warshall算法</h5><p>对于两个顶点i和j之间的最短路径，考虑是否存在一个中间顶点k，使得从i到k再到j的路径比直接从i到j的路径更短。算法通过三重循环遍历所有可能的中间顶点，不断更新距离矩阵。</p><p><strong>基本流程</strong></p><ol><li>初始化一个距离矩阵，矩阵中元素dist[i][j]表示从顶点i到j的直接距离。如果i和j之间没有直接连接，则设为无穷大</li><li>对于每一个顶点k，检查所有顶点对(i,j)</li><li>对于每一个顶点对(i,j)，如果dist[i][k] + dist[k][j] &lt; dist[i][j]，则更新dist[i][j]的值</li><li>重复步骤2和3，直到遍历完所有顶点</li></ol><p><strong>算法复杂度</strong></p><ul><li>时间复杂度：O(V³)，其中V是顶点数</li><li>空间复杂度：O(V²)</li></ul><p><strong>与迪杰斯特拉算法的比较</strong></p><ol><li><strong>范围不同</strong>：迪杰斯特拉是单源最短路径算法，而弗洛伊德是全源最短路径算法</li><li><strong>适用场景</strong>：<ul><li>对于稀疏图，运行V次迪杰斯特拉算法更高效</li><li>对于稠密图，弗洛伊德算法更优</li></ul></li><li><strong>负权边处理</strong>：弗洛伊德可以处理负权边，但两者都不能处理负权环</li></ol><p><strong>算法优势</strong></p><ol><li>实现简单，代码简洁</li><li>可以处理有向图和负权边（但不能有负权环）</li><li>一次运行可以得到所有顶点对之间的最短路径</li></ol><p><strong>应用场景</strong></p><ul><li>网络路由算法</li><li>交通规划</li><li>寻找图中的传递闭包</li><li>计算最大流问题</li></ul><h5 id="A-算法">A*算法</h5><p>A*算法是一种启发式搜索算法，常用于路径规划问题。</p><ul><li>结合了Dijkstra算法和启发式搜索的优点</li><li>使用估价函数指导搜索方向</li><li>在有好的启发函数时效率很高</li></ul><p><strong>基本流程</strong></p><ol><li>初始化：起点放入开放列表</li><li>每次从开放列表中选择f值最小的节点n</li><li>如果n是目标节点，算法结束</li><li>否则，将n移到关闭列表，并检查所有邻居节点</li><li>对于每个邻居，计算经过n的路径长度g和估计总长度f=g+h</li><li>更新邻居节点信息并加入开放列表</li><li>重复步骤2-6直到找到目标或开放列表为空</li></ol><h4 id="拓扑排序">拓扑排序</h4><p>拓扑排序是一种对有向无环图 (DAG, Directed Acyclic Graph) 中顶点进行线性排序的算法，使得对于图中的每一条有向边 (u, v)，顶点 u 在排序中都出现在顶点 v 之前。拓扑排序常用于表示具有依赖关系的任务调度问题。</p><p><strong>算法原理</strong></p><p>每次选择入度为0的顶点（即没有前驱顶点的顶点），将其输出，然后删除该顶点及其所有出边，重复此过程直到图为空或无法找到入度为0的顶点。</p><p><strong>时间复杂度与空间复杂度</strong></p><ul><li><strong>时间复杂度</strong>: O(V + E)，其中V是顶点数，E是边数</li><li><strong>空间复杂度</strong>: O(V)，需要存储顶点的访问状态和结果</li></ul><p><strong>特性和局限性</strong></p><ol><li><strong>唯一性</strong>: 拓扑排序的结果通常不唯一，可能有多种合法的排序方式</li><li><strong>环检测</strong>: 如果图中存在环，则无法进行拓扑排序</li><li><strong>适用范围</strong>: 只适用于有向无环图（DAG）</li><li><strong>初始点要求</strong>: 至少有一个顶点的入度为0，否则无法开始排序</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--回溯算法</title>
      <link href="/2025/03/12day/"/>
      <url>/2025/03/12day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯">回溯</h2><h3 id="组合">组合</h3><p>题目链接：<a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不写</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不写</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="回溯剪枝">回溯剪枝</h4><p>剪枝的地方就在递归中每一层的for循环所选择的起始位置。</p><p>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。</p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207.png" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合总和-III">组合总和 III</h3><p>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; an;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(an.<span class="built_in">size</span>()==k &amp;&amp; sum==n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(an);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            an.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            <span class="built_in">track</span>(n,k,i<span class="number">+1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">            an.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">track</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="电话号码的字母组合">电话号码的字母组合</h3><p>题目链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; ans; <span class="comment">// 存储最终结果，字符串组合</span></span><br><span class="line">    string combination;   <span class="comment">// 当前正在构建的字符串组合</span></span><br><span class="line">    string phoneMap[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;; <span class="comment">// 电话号码数字到字母的映射</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123; <span class="comment">// 递归终止条件：当处理完所有数字时</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(combination); <span class="comment">// 将当前组合添加到结果集</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> digitChar = digits[index]; <span class="comment">// 获取当前处理的数字字符</span></span><br><span class="line">        <span class="type">int</span> digitIndex = digitChar - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将数字字符转换为整数索引 (0-9)</span></span><br><span class="line">        string letters = phoneMap[digitIndex]; <span class="comment">// 获取数字对应的字母字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> letter : letters) &#123; <span class="comment">// 遍历当前数字对应的每个字母</span></span><br><span class="line">            combination.<span class="built_in">push_back</span>(letter); <span class="comment">// 将当前字母添加到组合中</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>); <span class="comment">// 递归处理下一个数字，索引 + 1</span></span><br><span class="line">            combination.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯：移除最后一个添加的字母，尝试下一个字母</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>(); <span class="comment">// 清空结果集</span></span><br><span class="line">        combination.<span class="built_in">clear</span>(); <span class="comment">// 清空当前组合</span></span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) &#123; <span class="comment">// 如果输入 digits 为空，直接返回空结果集</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>); <span class="comment">// 从 digits 的第一个数字开始回溯，索引从 0 开始</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合总和">组合总和</h3><p>题目链接：<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; an;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(an);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            an.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">track</span>(candidates, target - candidates[i], i); <span class="comment">// 注意这里是 i，允许重复使用同一元素</span></span><br><span class="line">            an.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        an.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">track</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合总和-II">组合总和 II</h3><p>题目链接：<a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; an;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> inx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(an);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = inx; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; inx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 如果该元素与左边元素相等，说明该搜索分支重复，直接跳过</span></span><br><span class="line">            an.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">track</span>(candidates, target - candidates[i], i + <span class="number">1</span>); </span><br><span class="line">            an.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">track</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集">子集</h3><p>题目链接：<a href="https://leetcode.cn/problems/subsets/">78. 子集</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; an;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(an);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=idx;i&lt;n;i++)&#123;</span><br><span class="line">            an.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">track</span>(nums,i<span class="number">+1</span>);</span><br><span class="line">            an.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">track</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集-II">子集 II</h3><p>题目链接：<a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; an;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(an);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=idx;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;idx &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            an.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">track</span>(nums,i<span class="number">+1</span>);</span><br><span class="line">            an.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">track</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--回溯算法</title>
      <link href="/2025/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯算法">回溯算法</h2><p>​<strong>回溯算法</strong> 是一种通过<strong>试错</strong>的方式寻找问题解的算法。它尝试逐步构建解决方案，如果在构建过程中的某一步发现当前的构建方案不可行，它会<strong>回溯</strong>（即取消最近一步的选择），然后尝试其他的可能性。这个过程就像是在迷宫中探索路径，当遇到死路时就退回上一个岔路口，选择另一条路继续前进。</p><h3 id="核心思想">核心思想</h3><ul><li><strong>试探性选择:</strong>  在每一步，都面临多个选择，回溯算法会先选择其中一个进行尝试。</li><li><strong>逐步构建:</strong>  它一步一步地构建可能的解。</li><li><strong>可行性判断 (约束条件):</strong> 在每一步构建后，都会检查当前的部分解是否满足问题的约束条件。</li><li><strong>回溯 (撤销选择):</strong> 如果发现当前部分解不可行，则撤销上一步的选择，回到之前的状态，并尝试其他的选择。</li><li><strong>终止条件:</strong> 当找到一个完整的可行解，或者当所有可能的选择都尝试完毕且没有找到解时，算法终止。</li></ul><h3 id="基本步骤">基本步骤</h3><ol><li><p><strong>定义问题的解空间：</strong> 确定问题的解可能存在的所有可能组合。例如，对于一个排列问题，解空间就是所有可能的排列。</p></li><li><p><strong>确定约束条件：</strong>  定义问题解必须满足的条件。这些条件用于判断当前构建的部分解是否有效。</p></li><li><p><strong>选择搜索策略 (通常是深度优先搜索 DFS)：</strong>  回溯算法通常使用深度优先搜索的方式来遍历解空间。</p></li><li><p><strong>设计递归函数 (或迭代方式模拟递归)：</strong></p><p>递归函数是实现回溯算法的关键。该函数通常包含以下几个部分：</p><ul><li><strong>基本情况 (终止条件)：</strong>  判断是否找到了一个完整的解，或者是否已经遍历完所有可能性但没有找到解。</li><li><strong>选择步骤：</strong>  在当前状态下，有哪些选择可以进行？</li><li><strong>扩展状态：</strong>  对于每个选择，更新状态，并递归调用自身进入下一层搜索。</li><li><strong>回溯步骤：</strong>  在递归调用返回后，需要撤销当前的选择，恢复到之前的状态，以便尝试其他的选择。</li></ul></li><li><p><strong>剪枝优化 (可选但重要)：</strong>  在搜索过程中，如果发现某个部分解已经不可能导致最终解，可以提前结束对该分支的搜索，以提高效率。这称为剪枝。</p></li></ol><h3 id="应用示例">应用示例</h3><p>回溯算法可以应用于解决许多经典问题，包括但不限于：</p><ol><li><strong>组合问题：</strong><ul><li><strong>组合总和 (Combination Sum):</strong>  在一个数字集合中找到所有和为目标值的组合。</li><li><strong>子集 (Subsets):</strong>  找出给定集合的所有子集。</li><li><strong>电话号码的字母组合 (Letter Combinations of a Phone Number):</strong>  给定数字字符串，返回所有可能的字母组合。</li></ul></li><li><strong>排列问题：</strong><ul><li><strong>全排列 (Permutations):</strong>  生成给定集合的所有排列。</li><li><strong>下一个排列 (Next Permutation):</strong>  找到给定排列的下一个字典序排列。</li></ul></li><li><strong>图论问题：</strong><ul><li><strong>N 皇后问题 (N-Queens Problem):</strong>  在 NxN 的棋盘上放置 N 个皇后，使其互不攻击。</li><li><strong>数独 (Sudoku Solver):</strong>  解决数独谜题。</li><li><strong>迷宫寻路 (Maze Solving):</strong>  找到迷宫的路径。</li><li><strong>图的着色问题 (Graph Coloring):</strong>  给图的顶点着色，使得相邻顶点颜色不同。</li><li><strong>旅行商问题 (Traveling Salesman Problem - TSP) (近似解或小规模问题)：</strong>  虽然TSP通常使用更优化的算法，但在小规模情况下，回溯可以找到解。</li></ul></li><li><strong>其他问题：</strong><ul><li><strong>0-1 背包问题 (0-1 Knapsack Problem)：</strong>  虽然动态规划更常用，但回溯也可以解决。</li><li><strong>正则表达式匹配 (Regular Expression Matching) (某些情况)：</strong>  复杂的正则表达式匹配问题可以使用回溯解决。</li><li><strong>解方程 (Solving Equations) (某些类型)：</strong>  例如，约束满足问题 (Constraint Satisfaction Problems - CSPs)。</li></ul></li></ol><h3 id="回溯算法模板">回溯算法模板</h3><p>回溯法其实就是暴力查找，回溯法解决的问题都可以抽象为树形结构（N叉树）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--线性表</title>
      <link href="/2025/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2025/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线性表">线性表</h2><p>线性表是⼀对⼀的逻辑结构，线性表中除了表头元素每个元素有且仅有唯⼀⼀个前驱元素，除了表尾元素，每个结点都有唯⼀⼀个后继节点。</p><h3 id="顺序存储（顺序表）">顺序存储（顺序表）</h3><h5 id="存取">存取</h5><p>顺序表随机存取，存取某个元素的时间复杂度为O(1)。</p><h5 id="查找">查找</h5><p>平均时间复杂度O(n)</p><h5 id="插入删除">插入删除</h5><p>平均时间复杂度O(n)，删除插⼊元素需要移动⼤量元素。（如果是删除最后⼀个元素或者在最后⼀个节点后⾯插⼊⼀个新的节点，则复杂度为O(1)，因为不需要移动元素）</p><h3 id="链式存储（链表）">链式存储（链表）</h3><p>链表因其链状的结构，能方便地删除、插入数据，操作次数是 O(1)。但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 O(n)。</p><h4 id="单链表">单链表</h4><p>单链表的基本组成单元是<strong>节点 (Node)</strong>。 每个节点通常包含两个主要部分：</p><ul><li><strong>数据域 (Data):</strong> 用于存储实际的数据元素。 数据域可以是任何数据类型，例如整数、浮点数、字符、字符串，甚至更复杂的数据结构。</li><li><strong>指针域 (Pointer) 或 下一个节点指针 (Next Pointer):</strong>  用于存储指向链表中<strong>下一个节点</strong>的地址（或引用）。  对于单链表，每个节点只有一个指针，指向它后面的节点。  链表的最后一个节点的指针域通常指向一个特殊值，表示链表的末尾，这个特殊值通常是 <strong>空指针 (NULL 或 None)</strong>。</li></ul><h5 id="创建链表">创建链表</h5><p>**头插法：**每次在链表头结点后⾯插⼊新的结点。头插法的元素顺序与插⼊顺序相反，类似于栈。</p><p>**尾插法：**每次在链表的尾结点插⼊新的结点，并且是尾结点更新（使尾指针指向新的尾结点）。尾插法得到的顺序与插⼊顺序相同，类似于队列。</p><h5 id="查找-2">查找</h5><p>查找方式是<strong>线性的</strong>，平均和最坏情况下的时间复杂度均为 <strong>O(n)</strong>，其中 <em>n</em> 是链表中的节点数。</p><p><strong>插入删除</strong></p><p>在链表中插入或删除节点，通常只需要修改指针的指向，而不需要像数组那样移动大量的元素（特别是插入和删除中间位置的元素时）。  时间复杂度通常为 O(1) (在已知插入/删除位置的前驱节点的情况下)。</p><h5 id="单链表的缺点">单链表的缺点</h5><ul><li><strong>访问效率较低:</strong>  要访问链表中的某个特定节点，必须从头节点开始顺序遍历，直到找到目标节点。  无法像数组那样通过索引直接访问，访问时间复杂度为 O(n)，其中 n 是链表的长度。</li><li><strong>存储开销:</strong>  每个节点除了存储数据外，还需要额外的空间存储指针，增加了存储开销。</li><li><strong>不适合随机访问:</strong> 由于只能顺序访问，链表不适合需要频繁随机访问的应用场景。</li></ul><h4 id="双链表">双链表</h4><p>双链表的节点 (Node) 结构在单链表的基础上增加了一个前驱指针：</p><ul><li><strong>前驱指针域 (Previous Pointer):</strong>  存储指向链表中<strong>前一个节点</strong>的地址（或引用）。 链表的<strong>头节点 (Head)</strong> 的前驱指针通常指向一个特殊值，表示链表头部，这个值通常是 <strong>空指针 (NULL 或 None)</strong>。</li><li><strong>数据域 (Data):</strong>  与单链表相同，用于存储数据元素。</li><li><strong>后继指针域 (Next Pointer):</strong>  与单链表相同，存储指向链表中<strong>下一个节点</strong>的地址（或引用）。 链表的<strong>尾节点 (Tail)</strong> 的后继指针通常指向一个特殊值，表示链表尾部，这个值通常是 <strong>空指针 (NULL 或 None)</strong>。</li></ul><h5 id="创建链表-2">创建链表</h5><p>创建一个空的双链表，通常将头指针和尾指针都初始化为 NULL。</p><h5 id="查找-3">查找</h5><p>与单链表类似，双链表的查找也是<strong>线性的</strong>，时间复杂度为 <strong>O(n)</strong>。</p><h5 id="双链表的优点">双链表的优点</h5><ul><li><strong>双向遍历:</strong>  可以从头到尾，也可以从尾到头双向遍历，提高了数据访问的灵活性。</li><li><strong>删除节点更高效:</strong>  删除节点时，特别是删除中间节点和尾节点时，由于有前驱指针，可以更方便地找到前一个节点，无需像单链表那样需要从头开始遍历找到前驱节点。 这在某些情况下可以提高删除操作的效率。</li><li><strong>某些操作更方便:</strong>  例如，在已知节点指针的情况下，插入和删除操作更加直接，不需要总是从头开始查找前驱节点。</li></ul><h5 id="双链表的缺点">双链表的缺点</h5><ul><li><strong>存储开销更大:</strong>  每个节点需要额外的空间存储前驱指针，相比单链表，存储相同的数据需要更多的内存。</li><li><strong>插入和删除操作更复杂:</strong>  虽然删除操作效率更高，但插入和删除操作的代码逻辑相对单链表来说更复杂，需要维护更多的指针关系（前驱和后继指针都需要更新）。</li><li><strong>访问效率仍然较低:</strong>  虽然可以双向遍历，但访问链表中的特定节点仍然需要顺序遍历，随机访问效率仍然不如数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--绪论</title>
      <link href="/2025/02/%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/02/%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="绪论">绪论</h2><h3 id="数据结构">数据结构</h3><p>数据结构是一门研究非数值计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科。</p><h4 id="逻辑结构">逻辑结构</h4><h5 id="线性结构">线性结构</h5><p>一般线性表：线性表</p><p>特殊线性表：栈、队列、字符串</p><p>线性表的推广：数组、广义表</p><h5 id="非线性结构">非线性结构</h5><p>树结构：树、二叉树</p><p>图结构：有向图、无向图</p><p>集合结构</p><h4 id="存储结构">存储结构</h4><h5 id="顺序存储">顺序存储</h5><p>逻辑上连续，物理上连续</p><p><strong>优点：</strong></p><ol><li><strong>随机访问高效</strong>：通过下标可直接访问元素，时间复杂度为 <strong>O(1)</strong>。</li><li><strong>内存连续，缓存友好</strong>：数据连续存放，充分利用 CPU 缓存机制，访问效率高。</li><li><strong>空间开销小</strong>：仅需存储数据，无需额外指针字段，内存利用率高。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>插入/删除效率低</strong>：在中间或头部操作时，需移动大量元素，时间复杂度为 <strong>O(n)</strong>。</li><li><strong>固定容量</strong>：需预先分配连续内存空间，扩容需复制全部数据，动态扩展成本高。</li><li><strong>内存浪费</strong>：若预分配空间过大，可能造成内存冗余。</li></ol><h5 id="链式存储">链式存储</h5><p>逻辑上不要求连续，物理上⼀定连续</p><p><strong>优点：</strong></p><ol><li><strong>动态内存分配</strong>：无需预先分配固定空间，按需动态扩展，内存利用率高。</li><li><strong>插入/删除高效</strong>：仅需修改指针指向，时间复杂度为 <strong>O(1)</strong>（需先定位到操作位置）。</li><li><strong>灵活性强</strong>：支持多种衍生结构（如双向链表、循环链表）。</li></ol><p><strong>缺点：</strong></p><ol><li><p><strong>无法随机访问</strong>：查找元素需从头遍历，时间复杂度为 <strong>O(n)</strong>。</p></li><li><p><strong>额外空间开销</strong>：每个节点需存储指针字段，占用更多内存。</p></li><li><p><strong>内存碎片化</strong>：节点非连续存储，缓存命中率低，访问速度较慢。</p></li></ol><h3 id="算法的效率">算法的效率</h3><p>算法是为了解决某类问题而规定的一个有限长的操作序列。</p><h4 id="算法时间复杂度">算法时间复杂度</h4><p>一般情况，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量记作: T(n)=O(f(n))</p><h4 id="算法空间复杂度">算法空间复杂度</h4><p>所⽤到的临时空间⼤⼩</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--二叉树</title>
      <link href="/2025/02/11day/"/>
      <url>/2025/02/11day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树">二叉树</h2><h3 id="完全二叉树的节点个数">完全二叉树的节点个数</h3><p>题目链接：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p><p>迭代法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树">平衡二叉树</h3><p>题目链接：<a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_height</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">get_height</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">get_height</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="number">-1</span> || <span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_height</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的所有路径">二叉树的所有路径</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p><p><strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path += <span class="built_in">to_string</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) <span class="built_in">traversal</span>(cur-&gt;left, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) <span class="built_in">traversal</span>(cur-&gt;right, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; treeSt; </span><br><span class="line">        stack&lt;string&gt; path;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) treeSt.<span class="built_in">push</span>(root);</span><br><span class="line">        path.<span class="built_in">push</span>(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span>(!treeSt.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node=treeSt.<span class="built_in">top</span>();</span><br><span class="line">            treeSt.<span class="built_in">pop</span>();</span><br><span class="line">            string p=path.<span class="built_in">top</span>();</span><br><span class="line">            path.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span> &amp;&amp; node-&gt;left==<span class="literal">NULL</span>) ans.<span class="built_in">push_back</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                path.<span class="built_in">push</span>(p+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(node-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                path.<span class="built_in">push</span>(p+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(node-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="左叶子之和">左叶子之和</h3><p>题目链接：<a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></p><p>感觉还是迭代法简单好想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left &amp;&amp; node-&gt;left-&gt;left==<span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right==<span class="literal">NULL</span>) sum+=node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="找树左下角的值">找树左下角的值</h3><p>题目链接：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></p><h4 id="迭代法">迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) ans=node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和">路径总和</h3><p>题目链接：<a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></p><h4 id="迭代法-2">迭代法</h4><p>这题和二叉树的所有路径很像，就是把存储路径改成存储路径和。</p><h5 id="版本一">版本一</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; sums;  <span class="comment">// 用来存储每个节点的路径和</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);  <span class="comment">// 将根节点压入栈</span></span><br><span class="line">            sums.<span class="built_in">push</span>(root-&gt;val);  <span class="comment">// 将根节点的值作为初始路径和压入路径和栈</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="type">int</span> sum = sums.<span class="built_in">top</span>();  <span class="comment">// 获取当前节点的路径和</span></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            sums.<span class="built_in">pop</span>();            </span><br><span class="line">            <span class="comment">// 判断是否是叶子节点并且路径和等于目标值</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; sum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// 继续将左右子节点和更新后的路径和压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                sums.<span class="built_in">push</span>(sum + node-&gt;right-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                sums.<span class="built_in">push</span>(sum + node-&gt;left-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="版本二">版本二</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; s; <span class="comment">// 使用栈存储节点和当前的路径和</span></span><br><span class="line">        s.<span class="built_in">push</span>(&#123;root, root-&gt;val&#125;); <span class="comment">// 初始化，根节点和它的值      </span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>().first;</span><br><span class="line">            <span class="type">int</span> currentSum = s.<span class="built_in">top</span>().second;</span><br><span class="line">            s.<span class="built_in">pop</span>();   </span><br><span class="line">            <span class="comment">// 判断是否是叶子节点，并且路径和是否等于目标值</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span> &amp;&amp; currentSum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="comment">// 将子节点和更新后的路径和压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) s.<span class="built_in">push</span>(&#123;node-&gt;right, currentSum + node-&gt;right-&gt;val&#125;);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) s.<span class="built_in">push</span>(&#123;node-&gt;left, currentSum + node-&gt;left-&gt;val&#125;);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归法">递归法</h4><h3 id="路径总和-II">路径总和 II</h3><p>题目链接：<a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉树遍历 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--二叉树</title>
      <link href="/2025/02/10day/"/>
      <url>/2025/02/10day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树层序遍历">二叉树层序遍历</h2><h3 id="二叉树层序遍历的模板">二叉树层序遍历的模板</h3><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif" style="zoom:67%;" /><p>第一种方法看了一遍代码+写 花了16分钟，挺简单的，递归法就先不看了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                re.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 递归法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == depth) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;left, result, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">order</span>(cur-&gt;right, result, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root, result, depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历-II">二叉树的层序遍历 II</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></p><p>五分钟结束战斗，就是上一个代码翻一下。但是性能有点慢，又交了一次时间也是超100%了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                re.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图">二叉树的右视图</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p><p>四分钟解决战斗，思考了不到一分钟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                re.<span class="built_in">push_back</span>(node-&gt;val); </span><br><span class="line">                <span class="comment">//代码随想录 if (i == (size - 1)) result.push_back(node-&gt;val); </span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(re[size<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层平均值">二叉树的层平均值</h3><p>题目链接：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></p><p>出了一点小插曲，花了五分钟，前边写的q后边写成p了，double第一次用的int忘了改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum+=node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum/s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="N-叉树的层序遍历">N 叉树的层序遍历</h3><p>题目链接：<a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></p><p>乍一看以为是第一题，看了一下不太明白孩子是啥意思，就直接看的题解，其实也没多大区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;children.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 将节点孩子加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[i]) que.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在每个树行中找最大值">在每个树行中找最大值</h3><p>题目链接：<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></p><p>花了8分钟，因为INT_MIN不知道如何操作，本来用的int，然后改成long long一点一点试的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> m=<span class="number">-1e14</span>;   <span class="comment">//int maxValue = INT_MIN; // 取每一层的最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;val&gt;m) m=node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h3><p>题目链接：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p><p>这题没想明白怎么处理，我是应该新建一个什么类型的vector，用int,char,Node类型都不行，然后就直接看题解了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            Node* prev = <span class="literal">NULL</span>;  <span class="comment">// 用来保存当前层级的前一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 连接前一个节点的next指针指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev-&gt;next = current;</span><br><span class="line">                <span class="comment">// 更新prev为当前节点</span></span><br><span class="line">                prev = current;</span><br><span class="line">                <span class="comment">// 将左子树和右子树加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前层级最后一个节点的next指针设置为NULL</span></span><br><span class="line">            prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用next指针逐层处理（优化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* leftmost = root; <span class="comment">// 当前层的最左节点</span></span><br><span class="line">        <span class="keyword">while</span> (leftmost-&gt;left) &#123; <span class="comment">// 直到叶子层</span></span><br><span class="line">            Node* curr = leftmost;</span><br><span class="line">            <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">                <span class="comment">// 连接左子节点和右子节点</span></span><br><span class="line">                curr-&gt;left-&gt;next = curr-&gt;right;</span><br><span class="line">                <span class="comment">// 连接右子节点和相邻节点的左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;next) &#123;</span><br><span class="line">                    curr-&gt;right-&gt;next = curr-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr-&gt;next; <span class="comment">// 移动到同层下一节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost-&gt;left; <span class="comment">// 移到下一层最左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="填充每个节点的下一个右侧节点指针-II">填充每个节点的下一个右侧节点指针 II</h3><p>题目链接：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            Node* prev = <span class="literal">NULL</span>;  <span class="comment">// 用来保存当前层级的前一个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 连接前一个节点的next指针指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev-&gt;next = current;</span><br><span class="line">                <span class="comment">// 更新prev为当前节点</span></span><br><span class="line">                prev = current;</span><br><span class="line">                <span class="comment">// 将左子树和右子树加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前层级最后一个节点的next指针设置为NULL</span></span><br><span class="line">            prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度">二叉树的最大深度</h3><p>题目链接：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><p>虽然简单，但是用这个方法有种高射炮打蚊子的感觉，感觉应该有更简单的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> s=q.<span class="built_in">size</span>();</span><br><span class="line">            sum=sum<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;</span><br><span class="line">                TreeNode* node=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归方法：后序遍历（DFS）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度">二叉树的最小深度</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p><p>找第一个没有左右子树的节点的深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录最小深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归</p><pre><code>如果 node 是空节点，由于没有节点，返回 0。如果 node 没有右儿子，那么深度就是左子树的深度加一，即 dfs(node)=dfs(node.left)+1。如果 node 没有左儿子，那么深度就是右子树的深度加一，即 dfs(node)=dfs(node.right)+1。如果 node 左右儿子都有，那么分别递归计算左子树的深度，以及右子树的深度，二者取最小值再加一，即 dfs(node)=min(dfs(node.left),dfs(node.right))+1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="翻转二叉树">翻转二叉树</h3><p>题目链接：<a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p><p>迭代法：深度优先遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 使用临时变量交换左右子节点</span></span><br><span class="line">            TreeNode* temp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = temp;</span><br><span class="line">            <span class="comment">// 如果左右子节点不为空，则加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树">对称二叉树</h3><p>题目链接：<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p><img src="https://code-thinking.cdn.bcebos.com/gifs/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif" style="zoom:67%;" /><p>迭代队列法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);   <span class="comment">// 将左子树头结点加入队列</span></span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);  <span class="comment">// 将右子树头结点加入队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 接下来就要判断这两个树是否相互翻转</span></span><br><span class="line">            TreeNode* leftNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="comment">// 左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;left);   <span class="comment">// 加入左节点左孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;right); <span class="comment">// 加入右节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;right);  <span class="comment">// 加入左节点右孩子</span></span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;left);  <span class="comment">// 加入右节点左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代栈法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; st; <span class="comment">// 这里改成了栈</span></span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        st.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* rightNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* leftNode = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            st.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉树遍历 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--二叉树</title>
      <link href="/2025/02/9day/"/>
      <url>/2025/02/9day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树前中后序遍历">二叉树前中后序遍历</h2><p>二叉树定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的前序遍历">二叉树的前序遍历</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><h4 id="递归遍历">递归遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代遍历">迭代遍历</h4><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node= s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="统一迭代法">统一迭代法</h4><p>每次加入一个右中左，接着将中全部输出，最后再按顺序输出栈里的内容，思路很直观，另外两种遍历也是如此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序遍历">二叉树的中序遍历</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><h4 id="递归遍历-2">递归遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代遍历-2">迭代遍历</h4><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif" style="zoom: 67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点及其左子树压入栈</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="统一迭代法-2">统一迭代法</h4><img src="https://code-thinking.cdn.bcebos.com/gifs/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span> (root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的后序遍历">二叉树的后序遍历</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><h4 id="递归遍历-3">递归遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root,vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        <span class="built_in">traversal</span>(root,re);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代遍历-3">迭代遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="统一迭代法-3">统一迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node =s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                s.<span class="built_in">push</span>(node);</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                node =s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉树遍历 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--STL</title>
      <link href="/2025/02/STL/"/>
      <url>/2025/02/STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>标准模板库（STL）</h1><p>STL 即标准模板库（Standard Template Library），是 C++  标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和  ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。</p><h2 id="STL容器">STL容器</h2><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250601144904492.png" style="zoom:50%;" /><h3 id="迭代器">迭代器</h3><p>​在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。</p><p>​迭代器听起来比较晦涩，其实迭代器本身可以看作一个数据指针。迭代器主要支持两个运算符：自增 (<code>++</code>) 和解引用（单目 <code>*</code> 运算符），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//下面两个 for 循环的效果是一样的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">  cout &lt;&lt; data[i] &lt;&lt; endl;  <span class="comment">// 使用下标访问元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = data.<span class="built_in">begin</span>(); iter != data.<span class="built_in">end</span>(); iter++)</span><br><span class="line">  cout &lt;&lt; *iter &lt;&lt; endl;  <span class="comment">// 使用迭代器访问元素</span></span><br><span class="line"><span class="comment">// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码</span></span><br></pre></td></tr></table></figure><p>​<a href="https://oi-wiki.org/lang/csl/container/">STL 容器</a> 一般支持从一端或两端开始的访问，以及对 <a href="https://oi-wiki.org/lang/const/">const 修饰符</a> 的支持。例如容器的 <code>begin()</code> 函数可以获得指向容器第一个元素的迭代器，<code>rbegin()</code> 函数可以获得指向容器最后一个元素的反向迭代器，<code>cbegin()</code> 函数可以获得指向容器第一个元素的 const 迭代器，<code>end()</code> 函数可以获得指向容器尾端（「尾端」并不是最后一个元素，可以看作是最后一个元素的后继；「尾端」的前驱是容器里的最后一个元素，其本身不指向任何一个元素）的迭代器。</p><h3 id="序列式容器">序列式容器</h3><ul><li><strong>向量</strong>(<code>vector</code>) 后端可高效增加元素的顺序表。</li><li><strong>双端队列</strong>(<code>deque</code>) 双端都可高效增加元素的顺序表。</li><li><strong>列表</strong>(<code>list</code>) 可以沿双向遍历的链表。</li><li><strong>单向列表</strong>(<code>forward_list</code>) 只能沿一个方向遍历的链表。</li></ul><h4 id="vector"><code>vector</code></h4><p><code>std::vector</code> 是 STL 提供的 <strong>内存连续的</strong>、<strong>可变长度</strong> 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。</p><h5 id="vector定义">vector定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>                       <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;                 <span class="comment">//相当于长度可以变化的一维数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt; &gt; name;        <span class="comment">//相当于长度可以变化的一维数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize]; </span><br><span class="line"><span class="comment">//一维长度固定为arraySize，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个vector容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typename可以是任何基本类型，例如int,double,char,结构体等，也可以是STL标准容器，例如vector,set,queue等</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建空vector; 常数复杂度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v0;</span><br><span class="line"><span class="comment">// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度</span></span><br><span class="line">v<span class="number">0.</span><span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 4. 创建一个初始空间为3的vector，其元素的默认值是1，</span></span><br><span class="line"><span class="comment">// 并且使用v2的空间配置器; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>, v<span class="number">2.</span>get_allocator())</span></span>;</span><br><span class="line"><span class="comment">// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"><span class="comment">// 6. 创建一个v4的拷贝vector v5，其内容是&#123;v4[1], v4[2]&#125;; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v<span class="number">4.</span>begin() + <span class="number">1</span>, v<span class="number">4.</span>begin() + <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(std::move(v2))</span></span>;  <span class="comment">// 或者 v6 = std::move(v2);</span></span><br></pre></td></tr></table></figure><h5 id="vector容器内元素的访问">vector容器内元素的访问</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过下标访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//直接访问m[index],index从0到m.size()-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//迭代器就像STL容器的“指针”，可以用*it访问vector中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m[i]和*(m.begin()+i)等价</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(it+i)); <span class="comment">//输出 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();it!=vi.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);    <span class="comment">//输出 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="vector常用函数">vector常用函数</h5><ol><li><p><code>push_back()</code> 在末尾插入一个元素，均摊复杂度为 <strong>常数</strong>，最坏为线性复杂度。</p></li><li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p></li><li><p><code>front()</code>返回vector的第一个元素，等价于*a.begin() 和 a[0]。</p></li><li><p><code>back()</code>返回vector的最后一个元素，等价于*==a.end() 和 a[a.size() – 1]。</p></li><li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p></li><li><p><code>v.data()</code> 返回指向数组第一个元素的指针。</p></li><li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<code>insert(it,x)</code>在it处插入x。</p></li><li><p><code>clear()</code> 清除所有元素。</p></li><li><p><code>erase()</code> 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。</p></li></ol><p>erase(it)删除迭代器为it处的元素，erase(first，last)即删除[first，last)内所有元素。</p><h4 id="deque"><code>deque</code></h4><p><code>std::deque</code>（双端队列）支持在头部和尾部进行高效插入删除的序列容器，与vector相比：</p><ul><li>头尾插入/删除时间复杂度为O(1)</li><li>支持随机访问（通过下标）</li><li>存储空间分块管理，迭代器比vector复杂</li><li>中间插入删除效率较低</li></ul><h5 id="deque定义">deque定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq1;              <span class="comment">// 空双端队列</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">char</span>&gt; <span class="title">dq2</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;     <span class="comment">// 包含5个&#x27;A&#x27;</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;    <span class="comment">// 列表初始化（C++11）</span></span><br></pre></td></tr></table></figure><h5 id="deque容器内元素的访问">deque容器内元素的访问</h5><table><thead><tr><th>方式</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>下标访问</td><td><code>dq[0]</code></td><td>无越界检查</td></tr><tr><td><code>at()</code> 方法</td><td><code>dq.at(0)</code></td><td>有越界检查，越界抛出异常</td></tr><tr><td>首元素</td><td><code>dq.front()</code></td><td>等价于 <code>dq[0]</code></td></tr><tr><td>末尾元素</td><td><code>dq.back()</code></td><td>等价于 <code>dq[dq.size()-1]</code></td></tr></tbody></table><h5 id="deque常用函数">deque常用函数</h5><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td><code>push_front(x)</code></td><td>在头部插入元素x</td></tr><tr><td><code>pop_front()</code></td><td>删除头部元素</td></tr><tr><td><code>push_back(x)</code></td><td>在尾部插入元素x</td></tr><tr><td><code>pop_back()</code></td><td>删除尾部元素</td></tr><tr><td><code>insert(pos, x)</code></td><td>在迭代器pos前插入元素x</td></tr><tr><td><code>erase(pos)</code></td><td>删除迭代器pos指向的元素</td></tr><tr><td><code>resize(n)</code></td><td>调整容器大小为n</td></tr><tr><td><code>shrink_to_fit()</code></td><td>请求移除未使用的容量（C++11）</td></tr></tbody></table><h5 id="特殊说明">特殊说明</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头尾操作示例</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">dq.<span class="built_in">push_front</span>(<span class="number">2</span>);    <span class="comment">// 头部插入：dq = [2]</span></span><br><span class="line">dq.<span class="built_in">push_back</span>(<span class="number">3</span>);     <span class="comment">// 尾部插入：dq = [2,3]</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>();      <span class="comment">// 删除头部：dq = [3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机访问示例</span></span><br><span class="line">dq[<span class="number">0</span>] = <span class="number">5</span>;          <span class="comment">// 修改第一个元素</span></span><br></pre></td></tr></table></figure><h5 id="综合对比">综合对比</h5><table><thead><tr><th>特性\容器</th><th>vector</th><th>deque</th></tr></thead><tbody><tr><td>头插效率</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾插效率</td><td>均摊O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(n)</td></tr><tr><td>内存布局</td><td>单块连续内存</td><td>多块连续内存</td></tr><tr><td>迭代器失效</td><td>容易失效</td><td>部分操作不失效</td></tr><tr><td>缓存友好性</td><td>高</td><td>较低</td></tr></tbody></table><h3 id="关联式容器">关联式容器</h3><ul><li><strong>集合</strong>(<code>set</code>) 用以有序地存储 <strong>互异</strong> 元素的容器，其实现是由节点组成的红黑树。</li><li><strong>多重集合</strong>(<code>multiset</code>) 用以有序地存储元素的容器。允许存在相等的元素。</li></ul><p>​头文件set，主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。</p><h4 id="set"><code>set</code></h4><p><code>set</code> 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。<code>set</code> 内部通常采用 <a href="https://oi-wiki.org/ds/rbtree/">红黑树</a> 实现。<a href="https://oi-wiki.org/ds/bst/">平衡二叉树</a> 的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p><h5 id="set定义">set定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;    <span class="comment">//set数组的定义和vector相同</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];</span><br></pre></td></tr></table></figure><h5 id="set容器内元素的访问">set容器内元素的访问</h5><p><code>set只能通过迭代器访问</code></p><p>set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持”++”和–“两个与算术相关的操作。</p><p>若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it将会指向排在“上一个”的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;   <span class="comment">//这样就得到了迭代器，可以通过*it来访问set</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：1 3 5</span></span><br></pre></td></tr></table></figure><h5 id="set常用函数">set常用函数</h5><ol><li><p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 <code>set</code> 中。</p></li><li><p><code>find(x)</code> 在 <code>set</code> 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 <code>end()</code>。</p></li><li><p><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</p></li></ol><p>​      <code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</p><p>​      <code>erase(first,last)</code> 删除迭代器在 [first,last) 范围内的所有元素。</p><ol start="4"><li><p><code>clear()</code> 清空 <code>set</code>。</p></li><li><p><code>count(x)</code> 返回 <code>set</code> 内键为 x 的元素数量。</p></li><li><p><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>empty()</code> 返回容器是否为空。</p></li><li><p><code>size()</code> 返回容器内元素个数。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现存可用的元素</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; available;</span><br><span class="line"><span class="comment">// 需要大于等于的值</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小的大于等于x的元素</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = available.<span class="built_in">lower_bound</span>(x);</span><br><span class="line"><span class="keyword">if</span> (it == available.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="comment">// 不存在这样的元素，则进行相应操作……</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 找到了这样的元素，将其从现存可用元素中移除</span></span><br><span class="line">  available.<span class="built_in">erase</span>(it);</span><br><span class="line">  <span class="comment">// 进行相应操作……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>映射</strong>(<code>map</code>) 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。</li><li><strong>多重映射</strong>(<code>multimap</code>) 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。</li></ul><h4 id="map"><code>map</code></h4><p><code>map</code> 是有序键值对容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。<code>map</code> 通常实现为 <a href="https://oi-wiki.org/ds/rbtree/">红黑树</a>。</p><h5 id="map定义">map定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key,value&gt; mp;</span><br><span class="line"><span class="comment">//字符串映射到整型，必须使用string而不能用char数组</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//将set容器映射到字符串</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;, string&gt; mp;</span><br></pre></td></tr></table></figure><h5 id="map容器内元素的访问">map容器内元素的访问</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过下标访问</span></span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//直接使用mp[&#x27;c&#x27;]来访问对应的整数，map中的键是唯一的。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">&#x27;c&#x27;</span>]=<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">&#x27;c&#x27;</span>]=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mp[<span class="string">&#x27;c&#x27;</span>]);  <span class="comment">//输出30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过迭代器访问</span></span><br><span class="line">map&lt;key,value&gt;::iterator it;</span><br><span class="line"><span class="comment">//map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">&#x27;m&#x27;</span>]=<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">&#x27;r&#x27;</span>]=<span class="number">30</span>;</span><br><span class="line">    mp[<span class="string">&#x27;a&#x27;</span>]=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：map会以键从小到大的顺序自动排序</span></span><br><span class="line"><span class="comment">// a 40</span></span><br><span class="line"><span class="comment">// m 20</span></span><br><span class="line"><span class="comment">// r 30</span></span><br></pre></td></tr></table></figure><h5 id="map常用函数">map常用函数</h5><ol><li><p>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;(&quot;Alan&quot;,100));</code>；</p></li><li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p></li><li><p><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</p></li></ol><p>​       <code>erase(pos)</code>: 删除迭代器为 pos 的元素，要求迭代器必须合法。</p><p>​       <code>erase(first,last)</code>: 删除迭代器在 [first,last) 范围内的所有元素。</p><ol start="4"><li><p><code>clear()</code> 函数会清空整个容器。</p></li><li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。复杂度为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="O(og(size)+ans)">（关于容器大小对数复杂度，加上匹配个数)。</p></li><li><p><code>lower_bound(x)</code>: 返回指向首个不小于给定键的元素的迭代器。</p></li><li><p><code>upper_bound(x)</code>: 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p></li><li><p><code>empty()</code>: 返回容器是否为空。</p></li><li><p><code>size()</code>: 返回容器内元素个数。</p></li></ol><h3 id="无序（关联式）容器">无序（关联式）容器</h3><ul><li><p><strong>无序（多重）集合</strong>(<code>unordered_set</code>/<code>unordered_multiset</code>)<strong>C++11</strong>，与 <code>set</code>/<code>multiset</code> 的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。</p></li><li><p><strong>无序（多重）映射</strong>(<code>unordered_map</code>/<code>unordered_multimap</code>)<strong>C++11</strong>，与 <code>map</code>/<code>multimap</code> 的区别在于键 (key) 无序，只关心 “键与值的对应关系”，使用哈希实现。</p></li></ul><h3 id="容器适配器">容器适配器</h3><p>容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 <code>clear()</code> 函数……）。</p><blockquote><p>「适配器是使一种事物的行为类似于另外一种事物行为的一种机制」，适配器对容器进行包装，使其表现出另外一种行为。</p></blockquote><ul><li><strong>栈</strong>(<code>stack</code>) 后进先出 (LIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>队列</strong>(<code>queue</code>) 先进先出 (FIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>优先队列</strong>(<code>priority_queue</code>) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（<code>vector</code>）的包装。</li></ul><h4 id="stack（栈）">stack（栈）</h4><p>STL <a href="https://oi-wiki.org/ds/stack/">栈</a>(<code>std::stack</code>) 是一种后进先出 (Last In, First Out) 的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。用来模拟实现一些递归。</p><h5 id="stack定义">stack定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">std::stack&lt;TypeName&gt; name;  <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName</span></span><br><span class="line">std::stack&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::stack&lt;TypeName&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;        <span class="comment">// 将 s1 复制一份用于构造 s2</span></span><br></pre></td></tr></table></figure><h5 id="stack容器内元素的访问">stack容器内元素的访问</h5><p>由于栈本身就是一种后进先出的数据结构，在STL的stack中只能通过top()来访问栈顶元素。</p><h5 id="stack常用函数">stack常用函数</h5><ol><li><p><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</p></li><li><p><code>push(x)</code> 向栈中插入元素 x</p></li><li><p><code>pop()</code> 删除栈顶元素</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h4 id="queue（队列）">queue（队列）</h4><p>STL <a href="https://oi-wiki.org/ds/queue/">队列</a>(<code>std::queue</code>) 是一种先进先出 (First In, First Out) 的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p><h5 id="queue定义">queue定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">std::queue&lt;TypeName&gt; name;  <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName</span></span><br><span class="line">std::queue&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;TypeName&gt; <span class="title">q2</span><span class="params">(q1)</span></span>;  <span class="comment">// 将 s1 复制一份用于构造 q2</span></span><br></pre></td></tr></table></figure><h5 id="queue容器内元素的访问">queue容器内元素的访问</h5><p>由于队列本身就是一种先进先出的数据结构，在STL的queue中只能通过front()来访问队首元素，通过back()访问队尾元素。</p><h5 id="queue常用函数">queue常用函数</h5><ol><li><p><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</p></li><li><p><code>back()</code> 访问队尾元素</p></li><li><p><code>push(x)</code> 向队列中插入元素 x</p></li><li><p><code>pop()</code> 删除队首元素</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h4 id="priority-queue（优先队列）">priority_queue（优先队列）</h4><p>优先队列 <code>std::priority_queue</code> 是一种 <a href="https://oi-wiki.org/ds/heap/">堆</a>，一般为 <a href="https://oi-wiki.org/ds/binary-heap/">二叉堆</a>。队首元素一定是当前队列中优先级最高的那一个。</p><h5 id="priority-queue定义">priority_queue定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;TypeName&gt; name;             <span class="comment">// 数据类型为 TypeName</span></span><br><span class="line">priority_queue&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line">priority_queue&lt;TypeName, Container, Compare&gt; name;</span><br><span class="line"><span class="comment">// 使用 Container 作为底层容器，使用 Compare 作为比较类型</span></span><br></pre></td></tr></table></figure><h5 id="priority-queue容器内元素的访问">priority_queue容器内元素的访问</h5><p>和队列不一样的是，优先队列没有front()和back()，只能通过top()访问队首元素(堆顶元素)。</p><h5 id="priority-queue常用函数">priority_queue常用函数</h5><ol><li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p></li><li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p></li><li><p><code>push(x)</code> 插入元素，并对底层容器排序</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h2 id="STL算法">STL算法</h2><p>STL 提供了大约 100 个实现算法的模版函数，基本都包含在 <code>&lt;algorithm&gt;</code> 之中，还有一部分包含在 <code>&lt;numeric&gt;</code> 和 <code>&lt;functional&gt;</code>。</p><h3 id="algorithm">algorithm</h3><p><code>&lt;algorithm&gt;</code> 头文件提供了大量通用算法，适用于多种容器。所有算法均通过迭代器操作，不对容器进行直接修改（除非明确说明）。</p><h4 id="常用算法列表">常用算法列表</h4><table><thead><tr><th>算法</th><th>功能说明</th></tr></thead><tbody><tr><td><code>sort(beg, end, cmp)</code></td><td>对区间[beg,end)排序，cmp为可选比较函数（默认升序）</td></tr><tr><td><code>reverse(beg, end)</code></td><td>反转指定区间的元素顺序</td></tr><tr><td><code>max(a, b)</code> / <code>min(a, b)</code></td><td>返回两个值的较大/较小值（C++11支持初始化列表：<code>max(&#123;1,2,3&#125;)</code>）</td></tr><tr><td><code>swap(a, b)</code></td><td>交换两个变量的值</td></tr><tr><td><code>find(beg, end, val)</code></td><td>在区间内查找值，返回首个匹配的迭代器，未找到返回end</td></tr><tr><td><code>count(beg, end, val)</code></td><td>统计区间内指定值出现的次数</td></tr><tr><td><code>fill(beg, end, val)</code></td><td>用指定值填充区间</td></tr><tr><td><code>copy(src_beg, src_end, dest_beg)</code></td><td>复制源区间到目标位置</td></tr><tr><td><code>unique(beg, end)</code></td><td>去除相邻重复元素，返回去重后的新结尾迭代器（通常先排序后使用）</td></tr><tr><td><code>lower_bound(beg, end, val)</code></td><td>在有序区间中找第一个不小于val的元素位置</td></tr><tr><td><code>upper_bound(beg, end, val)</code></td><td>在有序区间中找第一个大于val的元素位置</td></tr><tr><td><code>binary_search(beg, end, val)</code></td><td>检查有序区间中是否存在指定值</td></tr></tbody></table><h4 id="典型使用示例">典型使用示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a &gt; b; &#125;); <span class="comment">// 降序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重操作</span></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">erase</span>(last, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure><h2 id="pair">pair</h2><p><code>std::pair</code> 是一个模板类，用于将两个值组合成一个单元。常用于需要返回两个值的场景，或作为<code>map</code>容器的元素类型。通过灵活使用 <code>pair</code>，可以轻松应对 <strong>需要将关联数据捆绑存储、处理</strong> 的场景。</p><h3 id="pair定义">pair定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="comment">//可以在定义时直接完成 pair 的初始化。</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p0</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"><span class="comment">//也可以使用先定义，后赋值的方法完成 pair 的初始化。</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;   <span class="comment">// 默认构造：int=0, double=0.0</span></span><br><span class="line">p<span class="number">1.f</span>irst = <span class="number">1</span>;</span><br><span class="line">p<span class="number">1.</span>second = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//还可以使用 std::make_pair 函数。该函数接受两个变量，并返回由这两个变量组成的 pair。</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//在 C++11 以及之后的版本中，make_pair 可以配合 auto 使用，以避免显式声明数据类型。</span></span><br><span class="line"><span class="keyword">auto</span> p3 = <span class="built_in">make_pair</span>(<span class="number">3.14</span>, <span class="string">&quot;PI&quot;</span>);          <span class="comment">// 自动推导类型（C++11）</span></span><br></pre></td></tr></table></figure><h3 id="pair元素访问">pair元素访问</h3><table><thead><tr><th>成员变量</th><th>说明</th></tr></thead><tbody><tr><td><code>first</code></td><td>访问第一个元素</td></tr><tr><td><code>second</code></td><td>访问第二个元素</td></tr></tbody></table><h3 id="常用操作">常用操作</h3><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>比较运算符（==, !=, &lt;等）</td><td>按字典序比较：先比较first，相等时再比较second</td></tr><tr><td><code>swap</code></td><td>使用 <code>swap</code> 函数交换 <code>pair</code> 的值。</td></tr><tr><td>赋值</td><td>将 <code>pair</code> 的值赋给另一个类型一致的 <code>pair</code>。p0 = p1;</td></tr></tbody></table><h2 id="string">string</h2><p><code>std::string</code> 是 C++ 标准库提供的字符串类，用于存储和操作字符序列。它在内存中以连续块存储字符，支持高效的随机访问和动态调整大小。</p><h3 id="string定义">string定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string str1;                <span class="comment">// 空字符串</span></span><br><span class="line">std::string str2 = <span class="string">&quot;Hello&quot;</span>;      <span class="comment">// 用C风格字符串初始化</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;        <span class="comment">// 创建含5个&#x27;A&#x27;的字符串，输出&quot;AAAAA&quot;</span></span><br><span class="line"><span class="function">std::string <span class="title">str4</span><span class="params">(str2, <span class="number">1</span>, <span class="number">3</span>)</span></span>;    <span class="comment">// 从str2下标1开始取3个字符，输出&quot;ell&quot;</span></span><br></pre></td></tr></table></figure><h3 id="string容器内元素的访问">string容器内元素的访问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通过下标访问</span></span><br><span class="line">str[index]</span><br><span class="line"><span class="comment">//2. 通过迭代器访问</span></span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="comment">//可以通过*it访问string里的每一位</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it= str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string和vector一样，支持直接对迭代器进行加减某个字，str.begin()+3</span></span><br></pre></td></tr></table></figure><h3 id="string常用函数">string常用函数</h3><table><thead><tr><th>函数</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td><code>append(str)</code></td><td style="text-align:center">在字符串末尾追加内容</td></tr><tr><td><code>push_back(c)</code></td><td style="text-align:center">追加单个字符</td></tr><tr><td><code>pop_back()</code></td><td style="text-align:center">删除最后一个字符（C++11）</td></tr><tr><td><code>insert(pos, str)</code></td><td style="text-align:center">在指定位置插入字符串</td></tr><tr><td><code>erase(pos, len)</code></td><td style="text-align:center">从pos开始删除len个字符</td></tr><tr><td><code>replace(pos, len, str)</code></td><td style="text-align:center">替换从pos开始的len个字符为str</td></tr><tr><td><code>find(str, pos)</code></td><td style="text-align:center">从pos开始查找子串，返回首次出现的位置，未找到返回<code>string::npos</code></td></tr><tr><td><code>compare(str)</code></td><td style="text-align:center">比较字符串（返回0表示相等，负数表示小于，正数表示大于）</td></tr><tr><td><code>c_str()</code></td><td style="text-align:center">返回C风格字符串（const char*）</td></tr><tr><td><code>clear()</code></td><td style="text-align:center">清空字符串内容</td></tr><tr><td><code>resize(n, c)</code></td><td style="text-align:center">调整字符串长度为n，多出部分用字符c填充</td></tr><tr><td><code>capacity()</code></td><td style="text-align:center">返回当前分配的存储容量</td></tr><tr><td><code>reserve(n)</code></td><td style="text-align:center">预分配至少能存储n个字符的内存空间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> map </tag>
            
            <tag> queue </tag>
            
            <tag> stack </tag>
            
            <tag> deque </tag>
            
            <tag> STL </tag>
            
            <tag> vector </tag>
            
            <tag> string </tag>
            
            <tag> algorithm </tag>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--栈·队列</title>
      <link href="/2025/02/8day/"/>
      <url>/2025/02/8day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈·队列">栈·队列</h2><p>​                                     <img src="https://oi-wiki.org/ds/images/stack.svg" alt="栈：先进后出">                                               <img src="https://oi-wiki.org/ds/images/queue.svg" alt="队列：先进先出"></p><h3 id="stack">stack</h3><p>STL 中的 <code>stack</code> 容器提供了一众成员函数以供调用，其中较为常用的有：</p><ul><li>元素访问<ul><li><code>st.top()</code> 返回栈顶</li></ul></li><li>修改<ul><li><code>st.push()</code> 插入传入的参数到栈顶</li><li><code>st.pop()</code> 弹出栈顶</li></ul></li><li>容量<ul><li><code>st.empty()</code> 返回是否为空</li><li><code>st.size()</code> 返回元素数量</li></ul></li></ul><h3 id="queue">queue</h3><p>STL 中的 <code>queue</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p><ul><li>元素访问<ul><li><code>q.front()</code> 返回队首元素</li><li><code>q.back()</code> 返回队尾元素</li></ul></li><li>修改<ul><li><code>q.push()</code> 在队尾插入元素</li><li><code>q.pop()</code> 弹出队首元素</li></ul></li><li>容量<ul><li><code>q.empty()</code> 队列是否为空</li><li><code>q.size()</code> 返回队列中元素的数量</li></ul></li></ul><h3 id="deque">deque</h3><p>STL 中的 <code>deque</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p><ul><li>元素访问<ul><li><code>q.front()</code> 返回队首元素</li><li><code>q.back()</code> 返回队尾元素</li></ul></li><li>修改<ul><li><code>q.push_back()</code> 在队尾插入元素</li><li><code>q.pop_back()</code> 弹出队尾元素</li><li><code>q.push_front()</code> 在队首插入元素</li><li><code>q.pop_front()</code> 弹出队首元素</li><li><code>q.insert()</code> 在指定位置前插入元素（传入迭代器和元素）</li><li><code>q.erase()</code> 删除指定位置的元素（传入迭代器）</li></ul></li><li>容量<ul><li><code>q.empty()</code> 队列是否为空</li><li><code>q.size()</code> 返回队列中元素的数量</li></ul></li></ul><p>此外，<code>deque</code> 还提供了一些运算符。其中较为常用的有：</p><ul><li><p>使用赋值运算符 <code>=</code> 为 <code>deque</code> 赋值，类似 <code>queue</code>。</p></li><li><p>使用 <code>[]</code> 访问元素，类似 <code>vector</code>。</p></li></ul><h3 id="用栈实现队列">用栈实现队列</h3><p>题目链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果 B 栈为空，将 A 栈中的元素倒入 B 栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!A.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                B.<span class="built_in">push</span>(A.<span class="built_in">top</span>());</span><br><span class="line">                A.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveToB</span>(); <span class="comment">// 移动元素到 B 栈</span></span><br><span class="line">        <span class="type">int</span> val = B.<span class="built_in">top</span>();</span><br><span class="line">        B.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveToB</span>(); <span class="comment">// 移动元素到 B 栈</span></span><br><span class="line">        <span class="keyword">return</span> B.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">empty</span>() &amp;&amp; B.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用队列实现栈">用队列实现栈</h3><p>题目链接：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></p><h4 id="方法一：使用-一个队列">方法一：使用 <strong>一个队列</strong></h4><ol><li><strong>push(x)</strong>：<ul><li>首先，将元素 <code>x</code> 入队到队列末尾。</li><li>然后，将队列中前面已有的元素依次出队，再重新入队到队列末尾。<br>这样，队列的前端就始终是最新压入的元素，相当于实现了栈的“后进先出（LIFO）”顺序。</li></ul></li><li><strong>pop()</strong>：<ul><li>直接将队首元素出队即可。因为在上一步的处理里，队首元素就是栈顶。</li></ul></li><li><strong>top()</strong>：<ul><li>返回队首元素（不弹出）。</li></ul></li><li><strong>empty()</strong>：<ul><li>判断队列是否为空。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次 push 后，把前面的 (size - 1) 个元素依次出队并重新入队，确保新元素在队首</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 新元素先入队</span></span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// 2. 将前面的元素依次移到末尾</span></span><br><span class="line">        <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 只需要将前面的 (n - 1) 个元素移动到末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> val = q.<span class="built_in">front</span>();  <span class="comment">// 由于 push 中的旋转操作，队首就是栈顶</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();     <span class="comment">// 队首即为栈顶</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二：使用-两个队列">方法二：使用 <strong>两个队列</strong></h4><ol><li><strong>队列 A</strong> 和 <strong>队列 B</strong> 协同工作，保证其中一个队列始终存放当前所有元素，另一个队列用来做辅助操作。</li><li>push(x)：<ul><li>把新元素直接入队到<strong>空</strong>队列中（或者你可以总是把它放到 A，然后把 A 里旧的元素转移到 B，具体实现略有差异）。</li></ul></li><li>pop()：<ul><li>在 <code>pop()</code> 之前，我们需要把除最后一个元素外的所有元素，从一个队列（有数据的队列）依次出队并入队到另一个空队列，让最后一个元素留在原队列，然后弹出这个元素，这相当于栈顶元素。</li></ul></li><li>top()：<ul><li>类似 <code>pop()</code>，只是查看最后一个元素而不把它真正弹出。</li></ul></li><li>empty()：<ul><li>两个队列都为空即为真。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1, q2;  <span class="comment">// 两个队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 新元素先入空的队列 q2</span></span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 把 q1 中所有元素依次移到 q2 中</span></span><br><span class="line">        <span class="keyword">while</span> (!q<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">push</span>(q<span class="number">1.f</span>ront());</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 交换 q1 和 q2，保证所有元素又回到 q1，q2 变空</span></span><br><span class="line">        <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队首就是栈顶</span></span><br><span class="line">        <span class="type">int</span> val = q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q<span class="number">1.f</span>ront();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; q<span class="number">2.</span><span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有效的括号">有效的括号</h3><p>题目链接：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>题目思路：先判断一下s的长度是否为偶数，如果不是就返回false，再将全部的左符号压入栈中，然后开始判断剩余的符号是否可以匹配，如果不能就返回false，将s循环结束，如果全部匹配成功，最后应该栈是空的，如果不是返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) t.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>) t.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>) t.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t.<span class="built_in">empty</span>() || t.<span class="built_in">top</span>()!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项</h3><p>题目链接：<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p><p>建栈的写法，性能太差了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; t;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!t.<span class="built_in">empty</span>() &amp;&amp; s[i]==t.<span class="built_in">top</span>()) t.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> t.<span class="built_in">push</span>(s[i]); </span><br><span class="line">        &#125; </span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">while</span>(!t.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result=t.<span class="built_in">top</span>()+result;</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>string自己就可以做栈，string有pop和push接口，性能很高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">back</span>() == ch) &#123;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="逆波兰表达式求值">逆波兰表达式求值</h3><p>题目链接：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p><p>题目挺简单的，就是一个点需要注意：</p><p><strong><code>stoi()</code></strong>：</p><ul><li><code>stoi</code> 是一个将 <code>std::string</code> 类型转换为 <code>int</code> 的函数。如果 <code>tokens[i]</code> 是一个有效的整数表示，<code>stoi(tokens[i])</code> 将返回对应的整数值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="type">int</span> n=tokens.<span class="built_in">size</span>(),re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                re=a+b;</span><br><span class="line">                t.<span class="built_in">push</span>(re);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                re=b-a;</span><br><span class="line">                t.<span class="built_in">push</span>(re);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                re=b*a;</span><br><span class="line">                t.<span class="built_in">push</span>(re);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=t.<span class="built_in">top</span>();t.<span class="built_in">pop</span>();</span><br><span class="line">                re=b/a;</span><br><span class="line">                t.<span class="built_in">push</span>(re);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> t.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口最大值">滑动窗口最大值</h3><p>题目链接：<a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p><p>双端队列：队列中元素个数大于k，就删除队首元素，若入队元素大于队列中的元素，则把队列中的元素弹出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q; <span class="comment">// 双端队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 1. 入</span></span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>(); <span class="comment">// 维护 q 的单调性</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i); <span class="comment">// 入队</span></span><br><span class="line">            <span class="comment">// 2. 出</span></span><br><span class="line">            <span class="keyword">if</span> (i - q.<span class="built_in">front</span>() &gt;= k) &#123; <span class="comment">// 队首已经离开窗口了</span></span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 记录答案</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 由于队首到队尾单调递减，所以窗口最大值就是队首</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="前-K-个高频元素">前 K 个高频元素</h3><p>题目链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。<strong>小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><img src="https://code-thinking.cdn.bcebos.com/pics/347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.jpg" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// map&lt;nums[i],对应出现的次数&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 双端队列 </tag>
            
            <tag> 堆 </tag>
            
            <tag> queue </tag>
            
            <tag> stack </tag>
            
            <tag> deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--字符串</title>
      <link href="/2025/02/7day/"/>
      <url>/2025/02/7day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字符串">字符串</h2><p>​字符串，就是由字符连接而成的序列。常见的字符串问题包括字符串匹配问题、子串相关问题、前缀/后缀相关问题、回文串相关问题、子序列相关问题等。</p><h3 id="反转字符串">反转字符串</h3><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i++,j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> a=s[i];</span><br><span class="line">            s[i]=s[j];</span><br><span class="line">            s[j]=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转字符串-2">反转字符串</h3><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></p><p>注意一下reverse函数的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()  i, s.<span class="built_in">begin</span>() + i + k );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="替换数字">替换数字</h3><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1064">替换数字（第八期模拟笔试）</a></p><p>题目思路：看似简单，实则不好操作，gpt给的这个思路很好啊，重新弄一个新字符串然后拼接。代码随想录的那个太麻烦了，直接pass掉了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>  <span class="comment">// 需要 isdigit()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">replaceDigitsWithNumber</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            result += <span class="string">&quot;number&quot;</span>;  <span class="comment">// 仅替换数字</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += c;  <span class="comment">// 直接添加非数字字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;  <span class="comment">// 读取输入</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">replaceDigitsWithNumber</span>(s) &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要难点在于如何去掉空格，使用快慢指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭右闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="右旋字符串">右旋字符串</h3><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1065">右旋字符串</a></p><p>题目思路：和前边有一题很类似，都是申请了一个额外的空间往上加，这题是先把后n个加上，再把前m-n个加上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s,ans;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> m=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(m-n);i&lt;m;i++) ans+=s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(m-n);i++) ans+=s[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码随想录：它要求不申请额外的空间，这个就直接reverse两次，和上一题差不多，先全局再局部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>(); <span class="comment">//获取长度</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 整体反转</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n); <span class="comment">// 先反转前一段，长度n</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>()); <span class="comment">// 再反转后一段</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="找出字符串中第一个匹配项的下标">找出字符串中第一个匹配项的下标</h3><p>题目链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></p><p>暴力解法：思路正确，但是我写的代码写的太麻烦了，下边贴一份优雅的代码。时间复杂度O(m*n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()&gt;haystack.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:needle) s[i-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            <span class="keyword">if</span>(s[haystack[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t=i;</span><br><span class="line">                <span class="type">int</span> a=t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;needle.<span class="built_in">size</span>();j++) <span class="keyword">if</span>(haystack.<span class="built_in">size</span>()-a&gt;=needle.<span class="built_in">size</span>() &amp;&amp; haystack[a+j]==needle[j]) t++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((t-i)==needle.<span class="built_in">size</span>()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i, k = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">while</span>(k &lt; m <span class="keyword">and</span> s[j] == p[k])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k == m) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>**KMP解法：**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</p><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。代码随想录写的这个就很通俗易懂。</p><p><strong>Nex数组构造：</strong></p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line"><span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重复的子字符串">重复的子字符串</h3><p>题目链接：<a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p><p>暴力解法：想用暴力法写一下，结果写了两个小时，还是看了题解写出来的，钻牛角尖了。我写的代码性能不如官方代码高，贴一下官方代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> match = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[j] != s[j - i]) &#123;</span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移动匹配：将两个 s 连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s 就满足题目要求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = s + s;</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>()); t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(s) != std::string::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// r</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KMP实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span> <span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span> <span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, s);</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (next[len - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; len % (len - (next[len - <span class="number">1</span>] + <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> KMP </tag>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--哈希表</title>
      <link href="/2025/02/6day/"/>
      <url>/2025/02/6day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哈希表">哈希表</h2><p>​查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。一种以关键码的值**「key-value」<strong>而直接进行访问的</strong>数据结构**。<a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">总结</a></p><h3 id="四数相加Ⅱ">四数相加Ⅱ</h3><p>题目链接：<a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></p><p>题目思路：我刚开始的思路是for四次，但是算了一下，可能有点超时，然后就直接看题解了。将四个数组两两分成一组进行处理，时间复杂度就是O(n*n)。</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1) <span class="keyword">for</span>(<span class="type">int</span> b:nums2) umap[a+b]++;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:nums3) <span class="keyword">for</span>(<span class="type">int</span> d:nums4) <span class="keyword">if</span>(umap.<span class="built_in">find</span>(<span class="number">0</span>-(c+d))!=umap.<span class="built_in">end</span>()) count+=umap[<span class="number">0</span>-(c+d)];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="救赎金">救赎金</h3><p>题目链接：<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></p><p>题目思路：秒了，这和 <a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a> 几乎差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=magazine.<span class="built_in">size</span>(),m=ransomNote.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) j[magazine[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) j[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(j[i]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和">三数之和</h3><p>题目链接：<a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>题目思路1：感觉这题最不好处理的地方就是去重。三次循环，意料之中的超时了，当锻炼一下代码熟练度了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">+1</span>;k&lt;nums.<span class="built_in">size</span>();k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((nums[i]+nums[j]+nums[k])==<span class="number">0</span>) </span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">unique_nums</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result_vector</span>(unique_nums.<span class="built_in">begin</span>(), unique_nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result_vector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题目思路2：改了一下上一种方法，用哈希表进行处理。虽然可以通过，但是还是很慢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> target = <span class="number">0</span> - (nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">find</span>(target) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], target, nums[j]&#125;);   </span><br><span class="line">                    set.<span class="built_in">erase</span>(target);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">unique_nums</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result_vector</span>(unique_nums.<span class="built_in">begin</span>(), unique_nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result_vector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针：代码随想录的那个代码，感觉很多地方可以优化，所以就去找了一个优化完的代码。首先先将数组排序，我们只需要输出加和等于0的元素就可以，不用管次序。排序之后就可以从两端开始操作了，先创造一个大循环，用来固定住第一个数，然后再用双指针取操作另外两个数。</p><p>优化一：当最小的三个数的和大于0时，就可以直接退出循环了。</p><p>优化二：当最大的两个数加最小的那个数，还是小于0，就可以向前移动到再大的数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; x == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 优化一</span></span><br><span class="line">            <span class="keyword">if</span> (x + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 优化二</span></span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="type">int</span> s = x + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 三数之和为 0</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;x, nums[j], nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">for</span> (j++; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]; j++); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                    <span class="keyword">for</span> (k--; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]; k--); <span class="comment">// 跳过重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四数之和">四数之和</h3><p>题目链接：<a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></p><p>我的思路：做了半个小时，好几个小问题，思路和上一题一样，用同样的方法，只不过多了一层循环，需要多判断一下重复条件，那几个相加超范围不太会如何处理，chatgpt让它给的方案。看了一下代码随想录的思路，差不多，它加了两行剪枝代码，但是它的代码性能有点慢，加了也不如我的这个性能高，我也在代码中加上了那两行剪枝代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-3</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i<span class="number">+1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] &gt; target &amp;&amp; nums[i]+nums[j] &gt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//</span></span><br><span class="line">                <span class="type">int</span> c=j<span class="number">+1</span>,d=n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)nums[i]+nums[j]+nums[j<span class="number">+1</span>]+nums[j<span class="number">+2</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)nums[i]+nums[j]+nums[n<span class="number">-1</span>]+nums[n<span class="number">-2</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> sum=(<span class="type">long</span> <span class="type">long</span>)nums[i]+nums[j]+nums[c]+nums[d];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;target) d--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target) c++;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt; &#123;nums[i],nums[j],nums[c],nums[d]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d &amp;&amp; nums[c]==nums[c<span class="number">+1</span>]) c++;</span><br><span class="line">                        <span class="keyword">while</span>(c&lt;d &amp;&amp; nums[d]==nums[d<span class="number">-1</span>]) d--;</span><br><span class="line">                        c++;</span><br><span class="line">                        d--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--哈希表</title>
      <link href="/2025/02/5day/"/>
      <url>/2025/02/5day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哈希表">哈希表</h2><p>​查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。一种以关键码的值**「key-value」<strong>而直接进行访问的</strong>数据结构**。</p><h3 id="有效的字母异位词">有效的字母异位词</h3><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">242. 有效的字母异位词</a></p><p>题目描述：给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p><p>题目思路：创建一个哈希表，表长为26，哈希函数采用直接定址法，都不用处理冲突，还是比较简单的。直接排序，看是否两个数组相等应该也可以吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>(),m=t.<span class="built_in">size</span>(),q[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(m!=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) q[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) q[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(q[i]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组的交集">两个数组的交集</h3><p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p><p>题目描述：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集。输出结果中的每个元素一定是 <strong>唯一</strong> 的。</p><p>我的思路：感觉自己写的这个代码和屎一样，又臭又长，一点也不优雅。首先循环nums1数组，将出现的元素在s[]的位置变为1，然后再遍历第二个数组，如果出现和第一个数组相同的元素，则t[]对应位置变为1，再将这些位置存到一个新数组中，记录数组长度，然后构建一个正好长度的新数组，返回这个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums<span class="number">1.</span><span class="built_in">size</span>(),m=nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;,t[<span class="number">1001</span>]=&#123;<span class="number">-1</span>&#125;,num=<span class="number">0</span>,u=<span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) s[nums1[i]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span>(s[nums2[i]]==<span class="number">1</span>) t[nums2[i]]=<span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(u)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1001</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]&gt;<span class="number">0</span>)&#123;r[num]=i;</span><br><span class="line">            num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++) v[i]=r[i];</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码随想录题解：太高级了，看都看不懂，特意搜了一下这几个函数的用法。</p><p>​使用 <code>unordered_set&lt;int&gt; result</code> 来存储交集，这样可以自动去重，只保留一个 <code>nums2</code> 中与 <code>nums1</code> 相同的元素。</p><p><strong><code>set1.find(num)</code></strong>：</p><ul><li><code>find</code> 是 <code>unordered_set</code> 提供的一个成员函数，用于查找一个元素。如果元素存在，它会返回指向该元素的迭代器；如果元素不存在，它会返回指向 <strong><code>set1.end()</code></strong> 的迭代器。</li></ul><p><strong><code>set1.end()</code></strong>：</p><ul><li><code>set1.end()</code> 返回的是一个指向 <code>set1</code> 容器最后一个元素之后的位置的迭代器。它并不是容器中的一个有效元素，表示容器的末尾。</li></ul><p><strong><code>set1.find(num) != set1.end()</code></strong>：</p><ul><li>如果 <code>find(num)</code> 返回的迭代器与 <code>set1.end()</code> 不同，说明 <strong><code>num</code></strong> 存在于 <code>set1</code> 中。</li><li>如果 <code>find(num)</code> 返回的迭代器等于 <code>set1.end()</code>，说明 <strong><code>num</code></strong> 不存在于 <code>set1</code> 中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; </span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; </span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123; </span><br><span class="line">            hash[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123; </span><br><span class="line">            <span class="keyword">if</span> (hash[num] == <span class="number">1</span>) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快乐数">快乐数</h3><p>题目链接：<a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p><p>我的思路：我就随便试一下，就直接过了，因为不知道停止条件，所以直接设了个100次，性能还很高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">0</span>,t;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;t=n%<span class="number">10</span>;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">            num=num+t*t;</span><br><span class="line">            &#125;</span><br><span class="line">            n=num;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码随想录：题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="两数之和">两数之和</h3><p>题目链接：<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>暴力解法：我直接先用暴力解写了一下,比较简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i]+nums[j])==target) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希解法：思路还是挺好想的，但是代码不太会实现，不太熟练，自己写了一半，发现很多操作不会表达。直接贴一份代码随想录的代码。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>​此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p><p>map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><p><code>auto</code> 是 <strong>C++11</strong> 引入的 <strong>类型自动推导（Type Inference）</strong> 关键字，编译器会根据变量的 <strong>初始化值</strong> 自动推导出其数据类型，而无需手动声明类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]); </span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 查找 </tag>
            
            <tag> set </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识--哈希表</title>
      <link href="/2025/02/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2025/02/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哈希表">哈希表</h2><h3 id="哈希表概述">哈希表概述</h3><p>​<strong>哈希表：<strong>又称散列表，一种以关键码的值</strong>「key-value」<strong>而直接进行访问的</strong>数据结构</strong>。任意的键值 key  都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的  value。</p><p>​<strong>哈希函数：<strong>根据键值计算索引的函数就叫做</strong>哈希函数</strong>。</p><p>​**冲突：**不同的关键码映射到同一散列位置。key1!=key2，但是H(key1)=H(key2)。</p><p>​**同义词：**具有相同函数值的多个关键字。</p><p>​<strong>All in all:  将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素</strong> 。</p><p>​**需要解决的问题：**1. 哈希函数的构造。   2. 冲突解决的方法。</p><h3 id="哈希函数构造方法">哈希函数构造方法</h3><p>​哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布，以避免冲突。</p><h4 id="直接定址法">直接定址法</h4><p>**概述：**直接取关键字的某个线性函数值为哈希函数。</p><p>**哈希函数：**H(key) = key 或 H(key) = a*key + b   ( a和b为常数 )</p><p>**特点：**计算简单，不会产生冲突，适合关键字分布连续的情况（若不连续，则存储空间浪费很多，空间效率低）。</p><h4 id="除留余数法">除留余数法</h4><p>**概述：**指把key除以一个数mod得到的余数作为hash值的方法。当mod是一个质数时，H(key)能尽可能均匀覆盖每一个数。所以取mod为不大于表长Tsize但接近或等于表长的质数，<strong>即mod&lt;=Tsize且为质数</strong>。</p><p>**哈希函数：**H(key) = key % mod</p><p>**特点：**比较常用，关键在mod的选择，如何使得每个关键字通过该函数转换后等概率映射到散列空间的任一地址。</p><h4 id="平方取中法">平方取中法</h4><p>**概述：**指取key的平方的中间若干位作为hash值的方法，不常用。</p><p>**特点：**适合于关键字的每位取值都不够均匀或均小于散列地址所需位数。</p><h3 id="处理冲突的方法">处理冲突的方法</h3><h4 id="开放定址法（开地址法）">开放定址法（开地址法）</h4><p>**基本思想：**有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。Hi = (H(key) + di) % Tsize (di为增量序列)   计算新的哈希值。</p><h5 id="线性探查法">线性探查法</h5><p>​di = 0, 1, 2, … , Tsize-1</p><p>​发生冲突时，顺序表查看表中下一个元素，直到有空闲单元。会出现聚集现象，降低查询效率。</p><h5 id="平方探查法">平方探查法</h5><p>​di = 0² , +1² ,  -1² , +2² , -2² , … , +k² , -k²</p><p>​不会出现聚集现象，不能探测所有单元，但至少能探测一半</p><h5 id="伪随机探测法">伪随机探测法</h5><p>​di = 伪随机数序列</p><h4 id="链地址法（拉链法）">链地址法（拉链法）</h4><p>**基本思想：**和上边方法不同，链地址法不计算新的哈希值，而是把相同散列地址的记录链成一单链表。m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p><p>**优点：**1. 非同义词不会冲突，无&quot;聚集&quot;现象。</p><p>​   2. 链表上结点空间动态申请，更适合于表长不确定的情况（经常插入删除）。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" style="zoom:50%;" /><h3 id="哈希的查找及性能分析">哈希的查找及性能分析</h3><h4 id="查找过程">查找过程</h4><p>​检测由散列函数形成的地址上是否有记录，若无记录则失败； 若有记录比较关键字值，若相等则查找成功，否则散列函数更新增量值，重复执行。</p><h4 id="性能分析">性能分析</h4><p>​在列表查找中，使用最广泛的二分查找算法，复杂度为O(log2n)，但其始终只能用于有序列表。普通无序列表只能采用遍历查找，复杂度为O(n)。而拥有较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为常数级，即O(1)。  链地址法优于开放定址法，除留余数法作散列函数优于其它类型函数。</p><p>**装填因子：**∂=表中记录数/散列表长度。平均查找长度直接依赖于装填因子大小。也就是说，装填因子大小会直接影响到查找效率。装填因子越大，发生冲突的可能性越大。</p><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/ASL.png" style="zoom:33%;" /><p>​查找效率三个因素影响：哈希函数、装填因子、处理冲突方法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--链表</title>
      <link href="/2025/01/4day/"/>
      <url>/2025/01/4day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表操作">链表操作</h2><p>​链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域，最后一个节点的指针域指向null（空指针的意思）。</p><h3 id="两两交换链表中的节点">两两交换链表中的节点</h3><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">24. 两两交换链表中的节点</a></p><p>题目描述：两两交换链表中相邻的节点，并返回交换后链表的头节点</p><h4 id="虚拟头节点">虚拟头节点</h4><p>时间复杂度：O(n)     空间复杂度：O(1)</p><p>题目思路：直接对指针进行处理就行了。刚才随手写了一下，想着交一下看看哪里有bug呢，结果直接过了，也是挺顺的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* pre=dummy;</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp=pre-&gt;next;</span><br><span class="line">            ListNode* tmp1=pre-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next=head-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next=tmp;</span><br><span class="line">            pre-&gt;next-&gt;next-&gt;next=tmp1;</span><br><span class="line">            pre=tmp;</span><br><span class="line">            head=tmp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点">删除链表的倒数第 N 个结点</h3><p>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">9. 删除链表的倒数第 N 个结点</a></p><p>题目描述：删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><h4 id="快慢双指针法">快慢双指针法</h4><p>时间复杂度：O(n)     空间复杂度：O(1)</p><p>题目思路：又给秒了，定义一个快指针，一个慢指针，快指针先移动到第n个位置，然后开始快慢指针开始同时移动，当快指针指向尾节点的时候，慢指针正好指向导数第n个位置的前一个结点，略过倒数第n个结点，就结束了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* fast=dummy;</span><br><span class="line">        ListNode* slow=dummy;</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fast=fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp=slow-&gt;next;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表相交">链表相交</h3><p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p><p>题目描述：给定单链表的头节点 headA 和 headB ，找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><h4 id="思路1">思路1</h4><p>题目思路：求两个链表交点节点的指针。题目我都看不懂！看题解秒了。</p><p>求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置。比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。否则循环退出返回空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路二">思路二</h4><p>再贴个牛逼代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="literal">nullptr</span> ? A-&gt;next : headB;</span><br><span class="line">            B = B != <span class="literal">nullptr</span> ? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表">环形链表</h3><p>题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></p><p>题目描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>题目思路：很有生活的题，不太好想，看题解才明白怎么才能找到环的入口，也是挺有思维量的。想明白了就好了，记下来就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                ListNode* f=fast;</span><br><span class="line">                ListNode* s=head;</span><br><span class="line">                <span class="keyword">while</span>(f!=s)&#123;</span><br><span class="line">                    f=f-&gt;next;</span><br><span class="line">                    s=s-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--链表</title>
      <link href="/2025/01/3day/"/>
      <url>/2025/01/3day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表基础">链表基础</h2><p>​链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域，最后一个节点的指针域指向null（空指针的意思）。</p><h3 id="移除链表元素">移除链表元素</h3><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><p>题目描述：一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回新的头节点 。</p><h4 id="虚拟头节点">虚拟头节点</h4><p>时间复杂度：O(n)     空间复杂度：O(1)</p><p>题目思路：如果直接处理链表的话，需要考虑头节点，但是加入虚拟头节点就可以按照统一的方式去处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* pre=dummy;</span><br><span class="line">        pre-&gt;next=head;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next=head-&gt;next;</span><br><span class="line">                ListNode* tem=head;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre=head;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="直接操作">直接操作</h4><p>时间复杂度：O(n)     空间复杂度：O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归解法">递归解法</h4><p>时间复杂度：O(n)     空间复杂度：O(n)</p><p>题目思路：首先检查头节点的值是否为 val，如果是则移除头节点，答案即为在头节点的后续节点上递归的结果；如果头节点的值不为 val，则答案为头节点与在头节点的后续节点上递归得到的新链表拼接的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基础情况：空链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归处理</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">            ListNode* newHead = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转链表">反转链表</h3><p>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>题目描述：反转单链表，并返回反转后的链表。</p><h4 id="双指针法">双指针法</h4><p>时间复杂度：O(n)     空间复杂度：O(1)</p><p>题目思路：定义cur和pre指针，pre初始化为NULL，cur指向head，然后反转链表，cur-&gt;next指向pre，按逻辑移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* tem;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            tem=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="递归法">递归法</h4><p>思路和双指针差不多，明天研究一下。</p><p>时间复杂度：O(n)     空间复杂度：O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设计链表">设计链表</h3><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></p><p>题目描述：获取第index个节点的值，添加头节点，添加尾节点，在第 index 个节点之前添加值为 val 的节点，删除链表中的第 index 个节点。</p><h4 id="虚拟头节点-2">虚拟头节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;          <span class="comment">// 先定义 LinkedNode 结构体</span></span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LinkedNode* dummyhead;       <span class="comment">// 现在可以使用 LinkedNode 类型</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummyhead=<span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;(size<span class="number">-1</span>) || index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur=dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next=dummyhead-&gt;next;</span><br><span class="line">        dummyhead-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode=<span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur=dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>) index=<span class="number">0</span>;</span><br><span class="line">        LinkedNode* newNode=<span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur=dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;(size<span class="number">-1</span>) || index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur=dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tem=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tem;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚拟头节点（双链表）">虚拟头节点（双链表）</h4><p>还未看，直接copy的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用循环虚拟结点的双链表实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义双向链表节点结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DList</span> &#123;</span><br><span class="line">        <span class="type">int</span> elem; <span class="comment">// 节点存储的元素</span></span><br><span class="line">        DList *next; <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">        DList *prev; <span class="comment">// 指向上一个节点的指针</span></span><br><span class="line">        <span class="comment">// 构造函数，创建一个值为elem的新节点</span></span><br><span class="line">        <span class="built_in">DList</span>(<span class="type">int</span> elem) : <span class="built_in">elem</span>(elem), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        sentinelNode = <span class="keyword">new</span> <span class="built_in">DList</span>(<span class="number">0</span>); <span class="comment">// 创建哨兵节点，不存储有效数据</span></span><br><span class="line">        sentinelNode-&gt;next = sentinelNode; <span class="comment">// 哨兵节点的下一个节点指向自身，形成循环</span></span><br><span class="line">        sentinelNode-&gt;prev = sentinelNode; <span class="comment">// 哨兵节点的上一个节点指向自身，形成循环</span></span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">// 初始化链表大小为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表中第index个节点的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否超出范围</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果超出范围，返回-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> mid = size &gt;&gt; <span class="number">1</span>; <span class="comment">// 计算链表中部位置</span></span><br><span class="line">        DList *curNode = sentinelNode; <span class="comment">// 从哨兵节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; mid) &#123; <span class="comment">// 如果索引小于中部位置，从前往后遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;next; <span class="comment">// 移动到目标节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果索引大于等于中部位置，从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;prev; <span class="comment">// 移动到目标节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num = curNode-&gt;elem; <span class="comment">// 获取目标节点的值</span></span><br><span class="line">        <span class="keyword">return</span> num; <span class="comment">// 返回节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        DList *newNode = <span class="keyword">new</span> <span class="built_in">DList</span>(val); <span class="comment">// 创建新节点</span></span><br><span class="line">        DList *next = sentinelNode-&gt;next; <span class="comment">// 获取当前头节点的下一个节点</span></span><br><span class="line">        newNode-&gt;prev = sentinelNode; <span class="comment">// 新节点的上一个节点指向哨兵节点</span></span><br><span class="line">        newNode-&gt;next = next; <span class="comment">// 新节点的下一个节点指向原来的头节点</span></span><br><span class="line">        size++; <span class="comment">// 链表大小加1</span></span><br><span class="line">        sentinelNode-&gt;next = newNode; <span class="comment">// 哨兵节点的下一个节点指向新节点</span></span><br><span class="line">        next-&gt;prev = newNode; <span class="comment">// 原来的头节点的上一个节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        DList *newNode = <span class="keyword">new</span> <span class="built_in">DList</span>(val); <span class="comment">// 创建新节点</span></span><br><span class="line">        DList *prev = sentinelNode-&gt;prev; <span class="comment">// 获取当前尾节点的上一个节点</span></span><br><span class="line">        newNode-&gt;next = sentinelNode; <span class="comment">// 新节点的下一个节点指向哨兵节点</span></span><br><span class="line">        newNode-&gt;prev = prev; <span class="comment">// 新节点的上一个节点指向原来的尾节点</span></span><br><span class="line">        size++; <span class="comment">// 链表大小加1</span></span><br><span class="line">        sentinelNode-&gt;prev = newNode; <span class="comment">// 哨兵节点的上一个节点指向新节点</span></span><br><span class="line">        prev-&gt;next = newNode; <span class="comment">// 原来的尾节点的下一个节点指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表中的第index个节点之前添加值为val的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123; <span class="comment">// 检查索引是否超出范围</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果超出范围，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果索引为0或负数，在头部添加节点</span></span><br><span class="line">            <span class="built_in">addAtHead</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> mid = size &gt;&gt; <span class="number">1</span>; <span class="comment">// 计算链表中部位置</span></span><br><span class="line">        DList *curNode = sentinelNode; <span class="comment">// 从哨兵节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; mid) &#123; <span class="comment">// 如果索引小于中部位置，从前往后遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;next; <span class="comment">// 移动到目标位置的前一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            DList *temp = curNode-&gt;next; <span class="comment">// 获取目标位置的节点</span></span><br><span class="line">            DList *newNode = <span class="keyword">new</span> <span class="built_in">DList</span>(val); <span class="comment">// 创建新节点</span></span><br><span class="line">            curNode-&gt;next = newNode; <span class="comment">// 在目标位置前添加新节点</span></span><br><span class="line">            temp-&gt;prev = newNode; <span class="comment">// 目标位置的节点的前一个节点指向新节点</span></span><br><span class="line">            newNode-&gt;next = temp; <span class="comment">// 新节点的下一个节点指向目标位置的结点</span></span><br><span class="line">            newNode-&gt;prev = curNode; <span class="comment">// 新节点的上一个节点指向当前节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果索引大于等于中部位置，从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;prev; <span class="comment">// 移动到目标位置的后一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            DList *temp = curNode-&gt;prev; <span class="comment">// 获取目标位置的节点</span></span><br><span class="line">            DList *newNode = <span class="keyword">new</span> <span class="built_in">DList</span>(val); <span class="comment">// 创建新节点</span></span><br><span class="line">            curNode-&gt;prev = newNode; <span class="comment">// 在目标位置后添加新节点</span></span><br><span class="line">            temp-&gt;next = newNode; <span class="comment">// 目标位置的节点的下一个节点指向新节点</span></span><br><span class="line">            newNode-&gt;prev = temp; <span class="comment">// 新节点的上一个节点指向目标位置的节点</span></span><br><span class="line">            newNode-&gt;next = curNode; <span class="comment">// 新节点的下一个节点指向当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        size++; <span class="comment">// 链表大小加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的第index个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否超出范围</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果超出范围，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> mid = size &gt;&gt; <span class="number">1</span>; <span class="comment">// 计算链表中部位置</span></span><br><span class="line">        DList *curNode = sentinelNode; <span class="comment">// 从哨兵节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; mid) &#123; <span class="comment">// 如果索引小于中部位置，从前往后遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;next; <span class="comment">// 移动到目标位置的前一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            DList *next = curNode-&gt;next-&gt;next; <span class="comment">// 获取目标位置的下一个节点</span></span><br><span class="line">            curNode-&gt;next = next; <span class="comment">// 删除目标位置的节点</span></span><br><span class="line">            next-&gt;prev = curNode; <span class="comment">// 目标位置的下一个节点的前一个节点指向当前节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果索引大于等于中部位置，从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                curNode = curNode-&gt;prev; <span class="comment">// 移动到目标位置的后一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            DList *prev = curNode-&gt;prev-&gt;prev; <span class="comment">// 获取目标位置的下一个节点</span></span><br><span class="line">            curNode-&gt;prev = prev; <span class="comment">// 删除目标位置的节点</span></span><br><span class="line">            prev-&gt;next = curNode; <span class="comment">// 目标位置的下一个节点的下一个节点指向当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        size--; <span class="comment">// 链表大小减1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 链表的大小</span></span><br><span class="line">    DList *sentinelNode; <span class="comment">// 哨兵节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--数组</title>
      <link href="/2025/01/2day/"/>
      <url>/2025/01/2day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="滑动窗口">滑动窗口</h2><p>​刚开始不太好想到滑动窗口这种方法，即使想到了也并没有办法证明滑动窗口方法的正确性，现在我也不会证明。只是会用，前几天做过一次，这是第二次做，记住了这个方法之后也是没有什么障碍。</p><h3 id="例题">例题</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p>题目描述：找出数组中满足其总和大于等于 <code>target</code> 的长度最小的子数组，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">      <span class="type">int</span> sum=<span class="number">0</span>,m=<span class="number">100010</span>,j=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      &#123;</span><br><span class="line">        sum=sum+nums[i];</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">            m=<span class="built_in">min</span>(m,i-j<span class="number">+1</span>);</span><br><span class="line">            sum-=nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(m==<span class="number">100010</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相关题目">相关题目</h3><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></p><p>题目描述：找一个最长连续子数组，满足子数组中至多有两种数字。返回子数组的长度。</p><p>这题题目描述很抽象，没看懂啥意思，去评论区的解释。</p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p><p>不会做，没思路，目前水平不够，直接跳。</p><h2 id="矩阵规律">矩阵规律</h2><p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></p><p>题目描述：给定一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><h3 id="例题-2">例题</h3><h4 id="贪吃蛇输出">贪吃蛇输出</h4><p>题目思路：直接按顺序输出，定义上下左右四个边界，从左到右输出上边界加一，从上到下输出右边界减一，从右向左输出下边界减一，从下到上输出左边界加一，依次输出就可以，因为上边界加一，从上到下就少输出一个，右边界减一，从右到左输出就少输出一个。从下向上输出时，下边界减一，上边界加一，正好按顺序输出，完美！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,t=<span class="number">0</span>,b=n<span class="number">-1</span>,count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;=(n*n))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[t][i]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=t;j&lt;=b;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[j][r]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&gt;=l;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[b][j]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=b;j&gt;=t;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res[j][l]=count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="循环不变量原则">循环不变量原则</h4><p>思路：每条边按左闭右开的输出，每圈输出四次，每次输出边长减一个，这里直接贴一下代码随想录的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; </span><br><span class="line">        <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; </span><br><span class="line">        <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line">        <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">        <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j; j &lt; n - offset; j++) res[i][j] = count++;</span><br><span class="line">        <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i; i &lt; n - offset; i++) res[i][j] = count++;</span><br><span class="line">        <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) res[i][j] = count++;</span><br><span class="line">        <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) res[i][j] = count++;</span><br><span class="line">        <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">        <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) res[mid][mid] = count;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相关题目-2">相关题目</h3><p><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></p><p>进阶了一下，今天没时间了改天再做，这两天光建blog了。</p><p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">LCR 146. 螺旋遍历二维数组</a></p><p>这题虽然是简单题，但是做起来比例题难，这题边界问题比较棘手。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="built_in">empty</span>() || array[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 返回空 vector</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>,l=<span class="number">0</span>,r=array[<span class="number">0</span>].<span class="built_in">size</span>() <span class="number">-1</span>,b=array.<span class="built_in">size</span>()<span class="number">-1</span>,n=array[<span class="number">0</span>].<span class="built_in">size</span>()*array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &lt;= b &amp;&amp; l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) ans[j++]=array[t][i];</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=b;i++) ans[j++]=array[i][r];</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (t &lt;= b) &#123; <span class="comment">// 确保没有重复遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">                    ans[j++] = array[b][i];</span><br><span class="line">                &#125;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) &#123; <span class="comment">// 确保没有重复遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= t; i--) &#123;</span><br><span class="line">                    ans[j++] = array[i][l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><p><strong>前缀和 在涉及计算区间和的问题时非常有用</strong>！</p><p>刚开始使用的暴力解法，一直不行，知道看了题解才知道，故意卡暴力解。然后自己也想不出什么好方法，就问的chatgpt，这种方法刚开始我还以为时间复杂度差不多呢。</p><h3 id="例题-3">例题</h3><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1070/">区间和</a></p><p>题目描述：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    int a[n];</span><br><span class="line"></span><br><span class="line">    // 读取数组元素</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算前缀和数组</span><br><span class="line">    int prefixSum[n + 1];  // prefixSum[0] = 0</span><br><span class="line">    prefixSum[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        prefixSum[i] = prefixSum[i - 1] + a[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理区间查询</span><br><span class="line">    int l, r;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;, &amp;l, &amp;r) != EOF) &#123;</span><br><span class="line">        // 使用前缀和快速计算区间 [l, r] 的和</span><br><span class="line">        printf(&quot;%d\n&quot;, prefixSum[r + 1] - prefixSum[l]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关题目-3">相关题目</h3><p><a href="https://kamacoder.com/problempage.php?pid=1044/">开发商购买土地</a></p><p>看起来挺难的，没看懂题目意思，明天再研究。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 矩阵规律 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录--数组</title>
      <link href="/2025/01/1day/"/>
      <url>/2025/01/1day/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二分查找">二分查找</h2><p>每次去除当前区间一半的元素，时间复杂度O(logn)，注意处理好区间。</p><h3 id="例题">例题</h3><p>题目链接：<a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p><p>题目描述：在严格递增的序列中找到给定的数，并返回其下标。</p><h4 id="左闭右闭-left-right">左闭右闭 [left,right]</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target) l=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="左闭右开-left-right">左闭右开 [left,right)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) <span class="comment">//当l=r时没有意义，所以改为l&lt;r.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target) r=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target) l=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关题目">相关题目</h3><p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a><br>比较简单，处理一下返回值就可以。</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a><br>需要进行两次操作，找到左右边界，较复杂，还需要多做做。</p><p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a><br>我的思路是当(l-r)&lt;=1,找到的l便是整数部分。</p><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a><br>题目还未做</p><h2 id="双指针">双指针</h2><p>一种重要的编程思想，非常高效。</p><h3 id="例题-2">例题</h3><p>题目链接：<a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p><p>题目描述：给定一个数组 nums 和一个值 val，原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><h4 id="左右指针法">左右指针法</h4><p>思路：从两头向中间移动指针，当左边==val，右边！=val时，交换两个元素，边界问题不太好处理，较麻烦。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r &amp;&amp; nums[l]!=val) l++;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r &amp;&amp; nums[r]==val) r--;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)&#123; <span class="built_in">swap</span>(nums[l],nums[r]);</span><br><span class="line">            l++;</span><br><span class="line">            r--;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="快慢指针法">快慢指针法</h4><p>思路：定义一个快指针，用于一直向前循环，定义一个慢指针，当快指针指到的元素！=val时，将这个元素加入到慢指针指向的位置。快指针不会慢于慢指针，所以慢指针元素的更改就是它最后输出的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>,slow=<span class="number">0</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==val) fast++;</span><br><span class="line">            <span class="keyword">else</span> nums[slow++]=nums[fast++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关题目-2">相关题目</h3><p>26.删除有序数组中的重复项：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/</a></p><p>思路：快慢指针，题解中i为快指针，n为慢指针，当快慢指针指向的元素不相等时，更新慢指针，思路和例题中的差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) <span class="keyword">if</span>(nums[i]!=nums[n]) nums[++n]=nums[i];</span><br><span class="line">        <span class="keyword">return</span> n<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>283.移动零：<a href="https://leetcode.cn/problems/move-zeroes/solutions/2821184/san-chong-jie-fa-duo-yu-yan-you-pei-tu-b-1d3s/">https://leetcode.cn/problems/move-zeroes/solutions/2821184/san-chong-jie-fa-duo-yu-yan-you-pei-tu-b-1d3s/</a></p><p>思路：这题不太好想，前几天做过，这次看还是没思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>,tem;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tem=nums[i];</span><br><span class="line">                nums[i]=<span class="number">0</span>;</span><br><span class="line">                nums[n++]=tem;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>977.有序数组的平方：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p><p>这题印象比较深刻，前几天做的时候一直想不明白我的做法的问题，后来问了学长，才知道，我因为没有定义一个新数组，导致在原数组上操作导致的问题。直接定义int数组也不行，得用vector定义一个动态数组，没接触过vector也是不太会用，一直想着看看呢，也总是不想看。当时一直以为是超出int范围了。</p><p>思路：左右指针法，两边的数的平方向中间是递减的，所以比较两端，大的那一个就是剩下元素中最大的那个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, pos = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;  <span class="comment">// 创建 int 类型的结果数组</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> ll = nums[l] * nums[l];  </span><br><span class="line">            <span class="type">int</span> rr = nums[r] * nums[r];  </span><br><span class="line">            <span class="keyword">if</span> (ll &gt;= rr) &#123;</span><br><span class="line">                result[pos] = ll;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[pos] = rr;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回结果数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
