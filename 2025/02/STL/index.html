<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>基础知识--STL | WPIRONMAN</title><meta name="author" content="WP"><meta name="copyright" content="WP"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="标准模板库（STL） STL 即标准模板库（Standard Template Library），是 C++  标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和  ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。 STL容器  迭代"><meta property="og:type" content="article"><meta property="og:title" content="基础知识--STL"><meta property="og:url" content="https://wp-a.github.io/2025/02/STL/index.html"><meta property="og:site_name" content="WPIRONMAN"><meta property="og:description" content="标准模板库（STL） STL 即标准模板库（Standard Template Library），是 C++  标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和  ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。 STL容器  迭代"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp"><meta property="article:published_time" content="2025-02-10T16:11:46.000Z"><meta property="article:modified_time" content="2025-11-23T14:26:35.644Z"><meta property="article:author" content="WP"><meta property="article:tag" content="map"><meta property="article:tag" content="set"><meta property="article:tag" content="queue"><meta property="article:tag" content="stack"><meta property="article:tag" content="deque"><meta property="article:tag" content="STL"><meta property="article:tag" content="vector"><meta property="article:tag" content="string"><meta property="article:tag" content="algorithm"><meta property="article:tag" content="priority_queue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础知识--STL",
  "url": "https://wp-a.github.io/2025/02/STL/",
  "image": "https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp",
  "datePublished": "2025-02-10T16:11:46.000Z",
  "dateModified": "2025-11-23T14:26:35.644Z",
  "author": [
    {
      "@type": "Person",
      "name": "WP",
      "url": "https://wp-a.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://wpironman.oss-cn-qingdao.aliyuncs.com/favicon.png"><link rel="canonical" href="https://wp-a.github.io/2025/02/STL/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="manifest" href="/null"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{let a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n=o.globalFn||{};n[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Slab&amp;display=swap" media="print" onload="this.media=&quot;all&quot;"><script>let GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyloadPlugin:!1,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"基础知识--STL",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="/css/_custom/category/categories.css"><link rel="stylesheet" href="/css/categories.css"><link rel="stylesheet" href="/css/valine.css"><link rel="stylesheet" href="/css/transpancy.css"><link href="https://fonts.loli.net/css2?family=Noto+Sans+SC&amp;family=JetBrains+Mono&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Roboto+Slab&amp;display=swap" media="print" onload="this.media=&quot;all&quot;"><script>fetch("https://wpironman.top/pv").then(e=>e.json()).then(e=>{document.getElementById("my-pv").innerText=e.pv}).catch(()=>{document.getElementById("my-pv").innerText="获取失败"})</script><link rel="preload" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" as="style" onload="this.rel=&quot;stylesheet&quot;"><link href="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" as="image" crossorigin="anonymous"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image:url(https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/head.png" onerror="this.onerror=null,this.src=&quot;https://wpironman.oss-cn-qingdao.aliyuncs.com/head.gif&quot;" alt="avatar" loading="lazy"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/construction-detection/"><i class="fa-fw fas fa-hard-hat"></i><span> 工地检测</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i><span> 随机开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fa fa-taxi"></i><span> 异次元之旅</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/academic/"><i class="fa-fw fas fa-graduation-cap"></i><span> 学术主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo" loading="lazy"><span class="site-name">WPIRONMAN</span></a><a class="nav-page-title" href="/"><span class="site-name">基础知识--STL</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/construction-detection/"><i class="fa-fw fas fa-hard-hat"></i><span> 工地检测</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-user-group"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa-solid fa-user-tie"></i><span> 本站友链</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i><span> 随机开往</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://travel.moe/go.html?travel=on"><i class="fa-fw fa fa-taxi"></i><span> 异次元之旅</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/academic/"><i class="fa-fw fas fa-graduation-cap"></i><span> 学术主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基础知识--STL<a class="post-edit-link" href="null_posts/STL.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-10T16:11:46.000Z" title="发表于 2025-02-11 00:11:46">2025-02-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>标准模板库（STL）</h1><p>STL 即标准模板库（Standard Template Library），是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。由于其模板化的特点，它能够兼容自定义的数据类型，避免大量的造轮子工作。NOI 和 ICPC 赛事都支持 STL 库的使用，因此合理利用 STL 可以避免编写无用算法，并且充分利用编译器对模板库优化提高效率。</p><h2 id="STL容器">STL容器</h2><img src="https://wpironman.oss-cn-qingdao.aliyuncs.com/20250601144904492.png" style="zoom:50%" loading="lazy"><h3 id="迭代器">迭代器</h3><p>​	在 STL 中，迭代器（Iterator）用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似，但是它封装了一些有效性检查，并且提供了统一的访问格式。</p><p>​	迭代器听起来比较晦涩，其实迭代器本身可以看作一个数据指针。迭代器主要支持两个运算符：自增 (<code>++</code>) 和解引用（单目 <code>*</code> 运算符），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//下面两个 for 循环的效果是一样的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">  cout &lt;&lt; data[i] &lt;&lt; endl;  <span class="comment">// 使用下标访问元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = data.<span class="built_in">begin</span>(); iter != data.<span class="built_in">end</span>(); iter++)</span><br><span class="line">  cout &lt;&lt; *iter &lt;&lt; endl;  <span class="comment">// 使用迭代器访问元素</span></span><br><span class="line"><span class="comment">// 在C++11后可以使用 auto iter = data.begin() 来简化上述代码</span></span><br></pre></td></tr></tbody></table></figure><p>​	<a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/container/">STL 容器</a> 一般支持从一端或两端开始的访问，以及对 <a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/const/">const 修饰符</a> 的支持。例如容器的 <code>begin()</code> 函数可以获得指向容器第一个元素的迭代器，<code>rbegin()</code> 函数可以获得指向容器最后一个元素的反向迭代器，<code>cbegin()</code> 函数可以获得指向容器第一个元素的 const 迭代器，<code>end()</code> 函数可以获得指向容器尾端（「尾端」并不是最后一个元素，可以看作是最后一个元素的后继；「尾端」的前驱是容器里的最后一个元素，其本身不指向任何一个元素）的迭代器。</p><h3 id="序列式容器">序列式容器</h3><ul><li><strong>向量</strong>(<code>vector</code>) 后端可高效增加元素的顺序表。</li><li><strong>双端队列</strong>(<code>deque</code>) 双端都可高效增加元素的顺序表。</li><li><strong>列表</strong>(<code>list</code>) 可以沿双向遍历的链表。</li><li><strong>单向列表</strong>(<code>forward_list</code>) 只能沿一个方向遍历的链表。</li></ul><h4 id="vector"><code>vector</code></h4><p><code>std::vector</code> 是 STL 提供的 <strong>内存连续的</strong>、<strong>可变长度</strong> 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。</p><h5 id="vector定义">vector定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>                       <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;                 <span class="comment">//相当于长度可以变化的一维数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt; &gt; name;        <span class="comment">//相当于长度可以变化的一维数组</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize]; </span><br><span class="line"><span class="comment">//一维长度固定为arraySize，Arrayname[0]~Arrayname[arraySize-1]中每一个都是一个vector容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typename可以是任何基本类型，例如int,double,char,结构体等，也可以是STL标准容器，例如vector,set,queue等</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建空vector; 常数复杂度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v0;</span><br><span class="line"><span class="comment">// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度</span></span><br><span class="line">v<span class="number">0.</span><span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 4. 创建一个初始空间为3的vector，其元素的默认值是1，</span></span><br><span class="line"><span class="comment">// 并且使用v2的空间配置器; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>, v<span class="number">2.</span>get_allocator())</span></span>;</span><br><span class="line"><span class="comment">// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v2)</span></span>;</span><br><span class="line"><span class="comment">// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v<span class="number">4.</span>begin() + <span class="number">1</span>, v<span class="number">4.</span>begin() + <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(std::move(v2))</span></span>;  <span class="comment">// 或者 v6 = std::move(v2);</span></span><br></pre></td></tr></tbody></table></figure><h5 id="vector容器内元素的访问">vector容器内元素的访问</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过下标访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//直接访问m[index],index从0到m.size()-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//迭代器就像STL容器的“指针”，可以用*it访问vector中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m[i]和*(m.begin()+i)等价</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,*(it+i)); <span class="comment">//输出 1 2 3 4 5</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();it!=vi.<span class="built_in">end</span>();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);    <span class="comment">//输出 1 2 3 4 5</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="vector常用函数">vector常用函数</h5><ol><li><p><code>push_back()</code> 在末尾插入一个元素，均摊复杂度为 <strong>常数</strong>，最坏为线性复杂度。</p></li><li><p><code>pop_back()</code> 删除末尾元素，常数复杂度。</p></li><li><p><code>front()</code>返回vector的第一个元素，等价于*a.begin() 和 a[0]。</p></li><li><p><code>back()</code>返回vector的最后一个元素，等价于*==a.end() 和 a[a.size() – 1]。</p></li><li><p><code>size()</code> 返回容器长度（元素数量），即 <code>std::distance(v.begin(), v.end())</code>。</p></li><li><p><code>v.data()</code> 返回指向数组第一个元素的指针。</p></li><li><p><code>insert()</code> 支持在某个迭代器位置插入元素、可以插入多个。<code>insert(it,x)</code>在it处插入x。</p></li><li><p><code>clear()</code> 清除所有元素。</p></li><li><p><code>erase()</code> 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。</p></li></ol><p>erase(it)删除迭代器为it处的元素，erase(first，last)即删除[first，last)内所有元素。</p><h4 id="deque"><code>deque</code></h4><p><code>std::deque</code>（双端队列）支持在头部和尾部进行高效插入删除的序列容器，与vector相比：</p><ul><li>头尾插入/删除时间复杂度为O(1)</li><li>支持随机访问（通过下标）</li><li>存储空间分块管理，迭代器比vector复杂</li><li>中间插入删除效率较低</li></ul><h5 id="deque定义">deque定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq1;              <span class="comment">// 空双端队列</span></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">char</span>&gt; <span class="title">dq2</span><span class="params">(<span class="number">5</span>, <span class="string">'A'</span>)</span></span>;     <span class="comment">// 包含5个'A'</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq3 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};    <span class="comment">// 列表初始化（C++11）</span></span><br></pre></td></tr></tbody></table></figure><h5 id="deque容器内元素的访问">deque容器内元素的访问</h5><table><thead><tr><th>方式</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>下标访问</td><td><code>dq[0]</code></td><td>无越界检查</td></tr><tr><td><code>at()</code> 方法</td><td><code>dq.at(0)</code></td><td>有越界检查，越界抛出异常</td></tr><tr><td>首元素</td><td><code>dq.front()</code></td><td>等价于 <code>dq[0]</code></td></tr><tr><td>末尾元素</td><td><code>dq.back()</code></td><td>等价于 <code>dq[dq.size()-1]</code></td></tr></tbody></table><h5 id="deque常用函数">deque常用函数</h5><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td><code>push_front(x)</code></td><td>在头部插入元素x</td></tr><tr><td><code>pop_front()</code></td><td>删除头部元素</td></tr><tr><td><code>push_back(x)</code></td><td>在尾部插入元素x</td></tr><tr><td><code>pop_back()</code></td><td>删除尾部元素</td></tr><tr><td><code>insert(pos, x)</code></td><td>在迭代器pos前插入元素x</td></tr><tr><td><code>erase(pos)</code></td><td>删除迭代器pos指向的元素</td></tr><tr><td><code>resize(n)</code></td><td>调整容器大小为n</td></tr><tr><td><code>shrink_to_fit()</code></td><td>请求移除未使用的容量（C++11）</td></tr></tbody></table><h5 id="特殊说明">特殊说明</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头尾操作示例</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">dq.<span class="built_in">push_front</span>(<span class="number">2</span>);    <span class="comment">// 头部插入：dq = [2]</span></span><br><span class="line">dq.<span class="built_in">push_back</span>(<span class="number">3</span>);     <span class="comment">// 尾部插入：dq = [2,3]</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>();      <span class="comment">// 删除头部：dq = [3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机访问示例</span></span><br><span class="line">dq[<span class="number">0</span>] = <span class="number">5</span>;          <span class="comment">// 修改第一个元素</span></span><br></pre></td></tr></tbody></table></figure><h5 id="综合对比">综合对比</h5><table><thead><tr><th>特性\容器</th><th>vector</th><th>deque</th></tr></thead><tbody><tr><td>头插效率</td><td>O(n)</td><td>O(1)</td></tr><tr><td>尾插效率</td><td>均摊O(1)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(n)</td></tr><tr><td>内存布局</td><td>单块连续内存</td><td>多块连续内存</td></tr><tr><td>迭代器失效</td><td>容易失效</td><td>部分操作不失效</td></tr><tr><td>缓存友好性</td><td>高</td><td>较低</td></tr></tbody></table><h3 id="关联式容器">关联式容器</h3><ul><li><strong>集合</strong>(<code>set</code>) 用以有序地存储 <strong>互异</strong> 元素的容器，其实现是由节点组成的红黑树。</li><li><strong>多重集合</strong>(<code>multiset</code>) 用以有序地存储元素的容器。允许存在相等的元素。</li></ul><p>​	头文件set，主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。</p><h4 id="set"><code>set</code></h4><p><code>set</code> 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。<code>set</code> 内部通常采用 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">红黑树</a> 实现。<a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/bst/">平衡二叉树</a> 的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p><h5 id="set定义">set定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;    <span class="comment">//set数组的定义和vector相同</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];</span><br></pre></td></tr></tbody></table></figure><h5 id="set容器内元素的访问">set容器内元素的访问</h5><p><code>set只能通过迭代器访问</code></p><p>set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持”++”和–“两个与算术相关的操作。</p><p>若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it将会指向排在“上一个”的元素。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;   <span class="comment">//这样就得到了迭代器，可以通过*it来访问set</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    st.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it != st.<span class="built_in">end</span>();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：1 3 5</span></span><br></pre></td></tr></tbody></table></figure><h5 id="set常用函数">set常用函数</h5><ol><li><p><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 <code>set</code> 中。</p></li><li><p><code>find(x)</code> 在 <code>set</code> 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 <code>end()</code>。</p></li><li><p><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</p></li></ol><p>​ <code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</p><p>​ <code>erase(first,last)</code> 删除迭代器在 [first,last) 范围内的所有元素。</p><ol start="4"><li><p><code>clear()</code> 清空 <code>set</code>。</p></li><li><p><code>count(x)</code> 返回 <code>set</code> 内键为 x 的元素数量。</p></li><li><p><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 <code>end()</code>。</p></li><li><p><code>empty()</code> 返回容器是否为空。</p></li><li><p><code>size()</code> 返回容器内元素个数。</p></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现存可用的元素</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; available;</span><br><span class="line"><span class="comment">// 需要大于等于的值</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小的大于等于x的元素</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it = available.<span class="built_in">lower_bound</span>(x);</span><br><span class="line"><span class="keyword">if</span> (it == available.<span class="built_in">end</span>()) {</span><br><span class="line">  <span class="comment">// 不存在这样的元素，则进行相应操作……</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 找到了这样的元素，将其从现存可用元素中移除</span></span><br><span class="line">  available.<span class="built_in">erase</span>(it);</span><br><span class="line">  <span class="comment">// 进行相应操作……</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>映射</strong>(<code>map</code>) 由 {键，值} 对组成的集合，以某种比较键大小关系的谓词进行排列。</li><li><strong>多重映射</strong>(<code>multimap</code>) 由 {键，值} 对组成的多重集合，亦即允许键有相等情况的映射。</li></ul><h4 id="map"><code>map</code></h4><p><code>map</code> 是有序键值对容器，它的元素的键是唯一的。搜索、移除和插入操作拥有对数复杂度。<code>map</code> 通常实现为 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">红黑树</a>。</p><h5 id="map定义">map定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key,value&gt; mp;</span><br><span class="line"><span class="comment">//字符串映射到整型，必须使用string而不能用char数组</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//将set容器映射到字符串</span></span><br><span class="line">map&lt;set&lt;<span class="type">int</span>&gt;, string&gt; mp;</span><br></pre></td></tr></tbody></table></figure><h5 id="map容器内元素的访问">map容器内元素的访问</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过下标访问</span></span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//直接使用mp['c']来访问对应的整数，map中的键是唯一的。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'c'</span>]=<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mp[<span class="string">'c'</span>]);  <span class="comment">//输出30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过迭代器访问</span></span><br><span class="line">map&lt;key,value&gt;::iterator it;</span><br><span class="line"><span class="comment">//map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'m'</span>]=<span class="number">20</span>;</span><br><span class="line">    mp[<span class="string">'r'</span>]=<span class="number">30</span>;</span><br><span class="line">    mp[<span class="string">'a'</span>]=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">    }        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出：map会以键从小到大的顺序自动排序</span></span><br><span class="line"><span class="comment">// a 40</span></span><br><span class="line"><span class="comment">// m 20</span></span><br><span class="line"><span class="comment">// r 30</span></span><br></pre></td></tr></tbody></table></figure><h5 id="map常用函数">map常用函数</h5><ol><li><p>通过向 <code>map</code> 中插入一个类型为 <code>pair&lt;Key, T&gt;</code> 的值可以达到插入元素的目的，例如 <code>mp.insert(pair&lt;string,int&gt;("Alan",100));</code>；</p></li><li><p><code>find(x)</code>: 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 <code>end()</code>。</p></li><li><p><code>erase(key)</code> 函数会删除键为 <code>key</code> 的 <strong>所有</strong> 元素。返回值为删除元素的数量。</p></li></ol><p>​ <code>erase(pos)</code>: 删除迭代器为 pos 的元素，要求迭代器必须合法。</p><p>​ <code>erase(first,last)</code>: 删除迭代器在 [first,last) 范围内的所有元素。</p><ol start="4"><li><p><code>clear()</code> 函数会清空整个容器。</p></li><li><p><code>count(x)</code>: 返回容器内键为 x 的元素数量。复杂度为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="O(og(size)+ans)" loading="lazy">（关于容器大小对数复杂度，加上匹配个数)。</p></li><li><p><code>lower_bound(x)</code>: 返回指向首个不小于给定键的元素的迭代器。</p></li><li><p><code>upper_bound(x)</code>: 返回指向首个大于给定键的元素的迭代器。若容器内所有元素均小于或等于给定键，返回 <code>end()</code>。</p></li><li><p><code>empty()</code>: 返回容器是否为空。</p></li><li><p><code>size()</code>: 返回容器内元素个数。</p></li></ol><h3 id="无序（关联式）容器">无序（关联式）容器</h3><ul><li><p><strong>无序（多重）集合</strong>(<code>unordered_set</code>/<code>unordered_multiset</code>)<strong>C++11</strong>，与 <code>set</code>/<code>multiset</code> 的区别在于元素无序，只关心「元素是否存在」，使用哈希实现。</p></li><li><p><strong>无序（多重）映射</strong>(<code>unordered_map</code>/<code>unordered_multimap</code>)<strong>C++11</strong>，与 <code>map</code>/<code>multimap</code> 的区别在于键 (key) 无序，只关心 “键与值的对应关系”，使用哈希实现。</p></li></ul><h3 id="容器适配器">容器适配器</h3><p>容器适配器其实并不是容器。它们不具有容器的某些特点（如：有迭代器、有 <code>clear()</code> 函数……）。</p><blockquote><p>「适配器是使一种事物的行为类似于另外一种事物行为的一种机制」，适配器对容器进行包装，使其表现出另外一种行为。</p></blockquote><ul><li><strong>栈</strong>(<code>stack</code>) 后进先出 (LIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>队列</strong>(<code>queue</code>) 先进先出 (FIFO) 的容器，默认是对双端队列（<code>deque</code>）的包装。</li><li><strong>优先队列</strong>(<code>priority_queue</code>) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列，默认是对向量（<code>vector</code>）的包装。</li></ul><h4 id="stack（栈）">stack（栈）</h4><p>STL <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/stack/">栈</a>(<code>std::stack</code>) 是一种后进先出 (Last In, First Out) 的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。用来模拟实现一些递归。</p><h5 id="stack定义">stack定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">std::stack&lt;TypeName&gt; name;  <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName</span></span><br><span class="line">std::stack&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::stack&lt;TypeName&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;        <span class="comment">// 将 s1 复制一份用于构造 s2</span></span><br></pre></td></tr></tbody></table></figure><h5 id="stack容器内元素的访问">stack容器内元素的访问</h5><p>由于栈本身就是一种后进先出的数据结构，在STL的stack中只能通过top()来访问栈顶元素。</p><h5 id="stack常用函数">stack常用函数</h5><ol><li><p><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</p></li><li><p><code>push(x)</code> 向栈中插入元素 x</p></li><li><p><code>pop()</code> 删除栈顶元素</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h4 id="queue（队列）">queue（队列）</h4><p>STL <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/queue/">队列</a>(<code>std::queue</code>) 是一种先进先出 (First In, First Out) 的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p><h5 id="queue定义">queue定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">std::queue&lt;TypeName&gt; name;  <span class="comment">// 使用默认底层容器 deque，数据类型为 TypeName</span></span><br><span class="line">std::queue&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::queue&lt;TypeName&gt; <span class="title">q2</span><span class="params">(q1)</span></span>;  <span class="comment">// 将 s1 复制一份用于构造 q2</span></span><br></pre></td></tr></tbody></table></figure><h5 id="queue容器内元素的访问">queue容器内元素的访问</h5><p>由于队列本身就是一种先进先出的数据结构，在STL的queue中只能通过front()来访问队首元素，通过back()访问队尾元素。</p><h5 id="queue常用函数">queue常用函数</h5><ol><li><p><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</p></li><li><p><code>back()</code> 访问队尾元素</p></li><li><p><code>push(x)</code> 向队列中插入元素 x</p></li><li><p><code>pop()</code> 删除队首元素</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h4 id="priority-queue（优先队列）">priority_queue（优先队列）</h4><p>优先队列 <code>std::priority_queue</code> 是一种 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/heap/">堆</a>，一般为 <a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/binary-heap/">二叉堆</a>。队首元素一定是当前队列中优先级最高的那一个。</p><h5 id="priority-queue定义">priority_queue定义</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;TypeName&gt; name;             <span class="comment">// 数据类型为 TypeName</span></span><br><span class="line">priority_queue&lt;TypeName, Container&gt; name;  <span class="comment">// 使用 Container 作为底层容器</span></span><br><span class="line">priority_queue&lt;TypeName, Container, Compare&gt; name;</span><br><span class="line"><span class="comment">// 使用 Container 作为底层容器，使用 Compare 作为比较类型</span></span><br></pre></td></tr></tbody></table></figure><h5 id="priority-queue容器内元素的访问">priority_queue容器内元素的访问</h5><p>和队列不一样的是，优先队列没有front()和back()，只能通过top()访问队首元素(堆顶元素)。</p><h5 id="priority-queue常用函数">priority_queue常用函数</h5><ol><li><p><code>top()</code> 访问堆顶元素（此时优先队列不能为空）</p></li><li><p><code>pop()</code> 删除堆顶元素（此时优先队列不能为空）</p></li><li><p><code>push(x)</code> 插入元素，并对底层容器排序</p></li><li><p><code>size()</code> 查询容器中的元素数量</p></li><li><p><code>empty()</code> 询问容器是否为空</p></li></ol><h2 id="STL算法">STL算法</h2><p>STL 提供了大约 100 个实现算法的模版函数，基本都包含在 <code>&lt;algorithm&gt;</code> 之中，还有一部分包含在 <code>&lt;numeric&gt;</code> 和 <code>&lt;functional&gt;</code>。</p><h3 id="algorithm">algorithm</h3><p><code>&lt;algorithm&gt;</code> 头文件提供了大量通用算法，适用于多种容器。所有算法均通过迭代器操作，不对容器进行直接修改（除非明确说明）。</p><h4 id="常用算法列表">常用算法列表</h4><table><thead><tr><th>算法</th><th>功能说明</th></tr></thead><tbody><tr><td><code>sort(beg, end, cmp)</code></td><td>对区间[beg,end)排序，cmp为可选比较函数（默认升序）</td></tr><tr><td><code>reverse(beg, end)</code></td><td>反转指定区间的元素顺序</td></tr><tr><td><code>max(a, b)</code> / <code>min(a, b)</code></td><td>返回两个值的较大/较小值（C++11支持初始化列表：<code>max({1,2,3})</code>）</td></tr><tr><td><code>swap(a, b)</code></td><td>交换两个变量的值</td></tr><tr><td><code>find(beg, end, val)</code></td><td>在区间内查找值，返回首个匹配的迭代器，未找到返回end</td></tr><tr><td><code>count(beg, end, val)</code></td><td>统计区间内指定值出现的次数</td></tr><tr><td><code>fill(beg, end, val)</code></td><td>用指定值填充区间</td></tr><tr><td><code>copy(src_beg, src_end, dest_beg)</code></td><td>复制源区间到目标位置</td></tr><tr><td><code>unique(beg, end)</code></td><td>去除相邻重复元素，返回去重后的新结尾迭代器（通常先排序后使用）</td></tr><tr><td><code>lower_bound(beg, end, val)</code></td><td>在有序区间中找第一个不小于val的元素位置</td></tr><tr><td><code>upper_bound(beg, end, val)</code></td><td>在有序区间中找第一个大于val的元素位置</td></tr><tr><td><code>binary_search(beg, end, val)</code></td><td>检查有序区间中是否存在指定值</td></tr></tbody></table><h4 id="典型使用示例">典型使用示例</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>};</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b){ <span class="keyword">return</span> a &gt; b; }); <span class="comment">// 降序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重操作</span></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">erase</span>(last, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) std::cout &lt;&lt; <span class="string">"Found: "</span> &lt;&lt; *it;</span><br></pre></td></tr></tbody></table></figure><h2 id="pair">pair</h2><p><code>std::pair</code> 是一个模板类，用于将两个值组合成一个单元。常用于需要返回两个值的场景，或作为<code>map</code>容器的元素类型。通过灵活使用 <code>pair</code>，可以轻松应对 <strong>需要将关联数据捆绑存储、处理</strong> 的场景。</p><h3 id="pair定义">pair定义</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="comment">//可以在定义时直接完成 pair 的初始化。</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p0</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"><span class="comment">//也可以使用先定义，后赋值的方法完成 pair 的初始化。</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;   <span class="comment">// 默认构造：int=0, double=0.0</span></span><br><span class="line">p<span class="number">1.f</span>irst = <span class="number">1</span>;</span><br><span class="line">p<span class="number">1.</span>second = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//还可以使用 std::make_pair 函数。该函数接受两个变量，并返回由这两个变量组成的 pair。</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//在 C++11 以及之后的版本中，make_pair 可以配合 auto 使用，以避免显式声明数据类型。</span></span><br><span class="line"><span class="keyword">auto</span> p3 = <span class="built_in">make_pair</span>(<span class="number">3.14</span>, <span class="string">"PI"</span>);          <span class="comment">// 自动推导类型（C++11）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="pair元素访问">pair元素访问</h3><table><thead><tr><th>成员变量</th><th>说明</th></tr></thead><tbody><tr><td><code>first</code></td><td>访问第一个元素</td></tr><tr><td><code>second</code></td><td>访问第二个元素</td></tr></tbody></table><h3 id="常用操作">常用操作</h3><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>比较运算符（==, !=, &lt;等）</td><td>按字典序比较：先比较first，相等时再比较second</td></tr><tr><td><code>swap</code></td><td>使用 <code>swap</code> 函数交换 <code>pair</code> 的值。</td></tr><tr><td>赋值</td><td>将 <code>pair</code> 的值赋给另一个类型一致的 <code>pair</code>。p0 = p1;</td></tr></tbody></table><h2 id="string">string</h2><p><code>std::string</code> 是 C++ 标准库提供的字符串类，用于存储和操作字符序列。它在内存中以连续块存储字符，支持高效的随机访问和动态调整大小。</p><h3 id="string定义">string定义</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string str1;                <span class="comment">// 空字符串</span></span><br><span class="line">std::string str2 = <span class="string">"Hello"</span>;      <span class="comment">// 用C风格字符串初始化</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">'A'</span>)</span></span>;        <span class="comment">// 创建含5个'A'的字符串，输出"AAAAA"</span></span><br><span class="line"><span class="function">std::string <span class="title">str4</span><span class="params">(str2, <span class="number">1</span>, <span class="number">3</span>)</span></span>;    <span class="comment">// 从str2下标1开始取3个字符，输出"ell"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="string容器内元素的访问">string容器内元素的访问</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通过下标访问</span></span><br><span class="line">str[index]</span><br><span class="line"><span class="comment">//2. 通过迭代器访问</span></span><br><span class="line">string::iterator it;</span><br><span class="line"><span class="comment">//可以通过*it访问string里的每一位</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it= str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();it++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,*it);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//string和vector一样，支持直接对迭代器进行加减某个字，str.begin()+3</span></span><br></pre></td></tr></tbody></table></figure><h3 id="string常用函数">string常用函数</h3><table><thead><tr><th>函数</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td><code>append(str)</code></td><td style="text-align:center">在字符串末尾追加内容</td></tr><tr><td><code>push_back(c)</code></td><td style="text-align:center">追加单个字符</td></tr><tr><td><code>pop_back()</code></td><td style="text-align:center">删除最后一个字符（C++11）</td></tr><tr><td><code>insert(pos, str)</code></td><td style="text-align:center">在指定位置插入字符串</td></tr><tr><td><code>erase(pos, len)</code></td><td style="text-align:center">从pos开始删除len个字符</td></tr><tr><td><code>replace(pos, len, str)</code></td><td style="text-align:center">替换从pos开始的len个字符为str</td></tr><tr><td><code>find(str, pos)</code></td><td style="text-align:center">从pos开始查找子串，返回首次出现的位置，未找到返回<code>string::npos</code></td></tr><tr><td><code>compare(str)</code></td><td style="text-align:center">比较字符串（返回0表示相等，负数表示小于，正数表示大于）</td></tr><tr><td><code>c_str()</code></td><td style="text-align:center">返回C风格字符串（const char*）</td></tr><tr><td><code>clear()</code></td><td style="text-align:center">清空字符串内容</td></tr><tr><td><code>resize(n, c)</code></td><td style="text-align:center">调整字符串长度为n，多出部分用字符c填充</td></tr><tr><td><code>capacity()</code></td><td style="text-align:center">返回当前分配的存储容量</td></tr><tr><td><code>reserve(n)</code></td><td style="text-align:center">预分配至少能存储n个字符的内存空间</td></tr></tbody></table></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wp-a.github.io">WP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wp-a.github.io/2025/02/STL/">https://wp-a.github.io/2025/02/STL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wp-a.github.io" target="_blank">WPIRONMAN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/map/">map</a><a class="post-meta__tags" href="/tags/set/">set</a><a class="post-meta__tags" href="/tags/queue/">queue</a><a class="post-meta__tags" href="/tags/stack/">stack</a><a class="post-meta__tags" href="/tags/deque/">deque</a><a class="post-meta__tags" href="/tags/STL/">STL</a><a class="post-meta__tags" href="/tags/vector/">vector</a><a class="post-meta__tags" href="/tags/string/">string</a><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a><a class="post-meta__tags" href="/tags/priority-queue/">priority_queue</a></div><div class="post-share"><div class="social-share" data-image="https://wpironman.oss-cn-qingdao.aliyuncs.com/10year.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media=&quot;all&quot;"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/123.JPG" target="_blank"><img class="post-qr-code-img" src="/img/123.JPG" alt="微信" loading="lazy"></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/8day/" title="代码随想录--栈·队列"><img class="cover" src="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of previous post" loading="lazy"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">代码随想录--栈·队列</div></div><div class="info-2"><div class="info-item-1">代码随想录--栈·队列</div></div></div></a><a class="pagination-related" href="/2025/02/9day/" title="代码随想录--二叉树"><img class="cover" src="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of next post" loading="lazy"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">代码随想录--二叉树</div></div><div class="info-2"><div class="info-item-1">代码随想录--二叉树（1）前中后序遍历</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/8day/" title="代码随想录--栈·队列"><img class="cover" src="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" alt="cover" loading="lazy"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">代码随想录--栈·队列</div></div><div class="info-2"><div class="info-item-1">代码随想录--栈·队列</div></div></div></a><a class="pagination-related" href="/2025/02/5day/" title="代码随想录--哈希表"><img class="cover" src="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" alt="cover" loading="lazy"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-03</div><div class="info-item-2">代码随想录--哈希表</div></div><div class="info-2"><div class="info-item-1">代码随想录--哈希表（上）</div></div></div></a><a class="pagination-related" href="/2025/02/6day/" title="代码随想录--哈希表"><img class="cover" src="https://wpironman.oss-cn-qingdao.aliyuncs.com/1.webp" alt="cover" loading="lazy"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-04</div><div class="info-item-2">代码随想录--哈希表</div></div><div class="info-2"><div class="info-item-1">代码随想录--哈希表（下）</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><h1 id="site-title" fetchpriority="high" style="font-display:swap">基础知识--STL</h1></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">标准模板库（STL）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">STL容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">vector定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">vector容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">vector常用函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">deque定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">deque容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#deque%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">deque常用函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">特殊说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.2.5.</span> <span class="toc-text">综合对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">set定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">set容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">set常用函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">map定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">map容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">map常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%EF%BC%88%E5%85%B3%E8%81%94%E5%BC%8F%EF%BC%89%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">无序（关联式）容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">stack（栈）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stack%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">stack定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">stack容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stack%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.1.3.</span> <span class="toc-text">stack常用函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%EF%BC%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">queue（队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#queue%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">queue定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">queue容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.2.3.</span> <span class="toc-text">queue常用函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">priority_queue（优先队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#priority-queue%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">priority_queue定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#priority-queue%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.5.3.2.</span> <span class="toc-text">priority_queue容器内元素的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#priority-queue%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.3.3.</span> <span class="toc-text">priority_queue常用函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">STL算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#algorithm"><span class="toc-number">1.2.1.</span> <span class="toc-text">algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">常用算法列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">典型使用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pair"><span class="toc-number">1.3.</span> <span class="toc-text">pair</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pair%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">pair定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">pair元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text">常用操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">1.4.</span> <span class="toc-text">string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">string定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text">string容器内元素的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">string常用函数</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2025 By WP</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js" defer=""></script><script src="/js/main.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(()=>{var t=()=>{var t;window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise()):(window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(var e of document.querySelectorAll('script[type^="math/tex"]')){var a=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],a),n=document.createTextNode("");e.parentNode.replaceChild(n,e),a.start={node:n,delim:"",n:0},a.end={node:n,delim:"",n:0},t.math.push(a)}},""]}}},(t=document.createElement("script")).src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t))};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("pre"),a=(t.className="mermaid-src",t.hidden=!0,t.textContent=e.textContent,document.createElement("div"));a.className="mermaid-wrap",a.appendChild(t),e.parentNode.replaceWith(a)});let t=document.querySelectorAll("#article-container .mermaid-wrap");0!==t.length&&(e=()=>(e=>{window.loadMermaid=!0;let n="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,t)=>{let a=e.firstElementChild;e=`%%{init:{ 'theme':'${n}'}}%%
`+a.textContent,t=mermaid.render("mermaid-"+t,e);let d=e=>{a.insertAdjacentHTML("afterend",e)};"string"==typeof t?d(t):t.then(({svg:e})=>d(e))})})(t),btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.1/mermaid.min.js").then(e))};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{let n="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,o=null,a=(t,e)=>{n&&(window.shuoshuoComment.destroyValine=()=>{t.children.length&&(t.innerHTML="",t.classList.add("no-comment"))});e={el:"#vcomment",appId:"FXG14lTbR0Yj3W2kb3tkAt4L-gzGzoHsz",appKey:"hohJIUW6lOhfboJzq5FvG8z7",avatar:"monsterid",serverURLs:"https://fxg14ltb.lc-cn-n1-shared.com",emojiMaps:"",visitor:!1,...o,path:n?e:o&&o.path||window.location.pathname};new Valine(e)};var t=async(t,e)=>{"function"==typeof Valine||await btf.getScript("https://unpkg.com/valine@1.5.1/dist/Valine.min.js"),a(t,e)};n?window.shuoshuoComment={loadComment:t}:setTimeout(t,0)})()</script></div><script type="text/javascript" src="/js/reward.js" defer=""></script><script async="" src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.1/dist/echarts.min.js"></script><script data-pjax="" src="/js/hexo_githubcalendar.js?v=20250920"></script><script src="/js/fix-avatar.js"></script><script src="/js/jquery.tagcanvas.min.js"></script><script src="/js/blog-cool-features.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer=""></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"]):not([href="/gallery/"]):not([href="/about/"])',selectors:["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!1,scrollRestoration:!1});let t=e=>{e&&Object.values(e).forEach(e=>e())};document.addEventListener("pjax:send",()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),t(window.globalFn.pjaxSend)}),document.addEventListener("pjax:complete",()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach(e=>{let t=document.createElement("script");var a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)}),t(window.globalFn.pjaxComplete)}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js" defer=""></script></div></div><script data-pjax="" src="/js/hexo_githubcalendar.js?v=20251124"></script><script data-pjax="">function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://github-calendar-api.meta-code.top/api?user=wp-a",["#ebedf0","#a2f7af","#6ce480","#54ad63","#469252","#31753c","#1f5f2a","#13531f","#084111","#032b09","#000000"],"wp-a")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style></body></html>